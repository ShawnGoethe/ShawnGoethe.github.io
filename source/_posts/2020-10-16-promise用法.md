---
title: 2020-10-16-promise用法
date: 2020-10-16 18:42:09
tags:
---
# What

ECMAscript 6 原生提供了 Promise 对象。

Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。

### Promise 对象有以下两个特点:

1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：

- pending: 初始状态，不是成功或失败状态。
- fulfilled: 意味着操作成功完成。
- rejected: 意味着操作失败。

只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。

2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

```
var promise = new Promise(function(resolve, reject) {
    // 异步处理
    // 处理结束后、调用resolve 或 reject
});
```

以上来自:[菜鸟https://www.runoob.com/w3cnote/javascript-promise-object.html](https://www.runoob.com/w3cnote/javascript-promise-object.html)

# Why
因为在[2020年01月07日有一篇文章](/2020/01/07/2020-01-07-%E5%85%B3%E4%BA%8EPromise%E7%9A%84%E6%80%9D%E8%80%83/)讲了使用promise实现延时队列的一道面试题，因为之前写业务没有用到过所以一直以为用处不大，但今天对接阿里的`录音文件识别`转文字的接口中，示例代码是一个setInterval轮询得到结果的一种方式，但是他带来了一个很严重的问题

> ！！没有办法返回前端转文字的结果！！

大概代码如下

```js
//url:https://help.aliyun.com/document_detail/94242.html?spm=a2c4g.11174283.6.601.15eb7275a8rq00
// 这段代码会异步执行，可以得到结果，但是直接用这个代码返回给前端
client.submitTask(taskParams, options).then((response) => {
        console.log(response);
        // 服务端响应信息的状态描述StatusText。
        var statusText = response.StatusText;
        if (statusText != 'SUCCESS') {
            console.log('录音文件识别请求响应失败!')
            return;
        }
        console.log('录音文件识别请求响应成功!');
        // 获取录音文件识别请求任务的TaskId，以供识别结果查询使用。
        var taskId = response.TaskId;
        /**
         * 以TaskId为查询参数，提交识别结果查询请求。
         * 以轮询的方式进行识别结果的查询，直到服务端返回的状态描述为"SUCCESS"、SUCCESS_WITH_NO_VALID_FRAGMENT，
         * 或者为错误描述，则结束轮询。
        */
        var taskIdParams = {
            TaskId : taskId
        };
        var timer = setInterval(() => {
            client.getTaskResult(taskIdParams).then((response) => {
                console.log('识别结果查询响应：');
                console.log(response);
                var statusText = response.StatusText;
                if (statusText == 'RUNNING' || statusText == 'QUEUEING') {
                    // 继续轮询，注意间隔周期。
                }
                else {
                    if (statusText == 'SUCCESS' || statusText == 'SUCCESS_WITH_NO_VALID_FRAGMENT') {
                        console.log('录音文件识别成功：');
                        var sentences = response.Result;
                        console.log(sentences);
                    }
                    else {
                        console.log('录音文件识别失败!');
                    }
                    // 退出轮询
                    clearInterval(timer);
                }
            }).catch((error) => {
                console.error(error);
                // 异常情况，退出轮询。
                clearInterval(timer);
            });
        }, 10000);
    }).catch((error) => {
        console.error(error);
    });
}
```

# How



使用promise进行包裹，等到promise内部的函数取到了结果在返回

```js
if (statusText == 'SUCCESS' || statusText == 'SUCCESS_WITH_NO_VALID_FRAGMENT') {
                        console.log('录音文件识别成功：');
                        var sentences = response.Result;
                        console.log(sentences);
  											//这里新增resolve
} else {
                        console.log('录音文件识别失败!');
}
```

外层通过如下代码实现

```
var promise = new Promise(function(resolve, reject) {
    // 异步处理
    // 处理结束后、调用resolve 或 reject
});
```

```js
async function getWords() {
      return new Promise((resolve, reject) => {
        client
          .submitTask(taskParams, options)
          .then(response => {
            console.log(response);
            // 服务端响应信息的状态描述StatusText。
            const statusText = response.StatusText;
            if (statusText != 'SUCCESS') {
              console.log('录音文件识别请求响应失败!');
            }
            console.log('录音文件识别请求响应成功!');
            // 获取录音文件识别请求任务的TaskId，以供识别结果查询使用。
            const taskId = response.TaskId;
            /**
             * 以TaskId为查询参数，提交识别结果查询请求。
             * 以轮询的方式进行识别结果的查询，直到服务端返回的状态描述为"SUCCESS"、SUCCESS_WITH_NO_VALID_FRAGMENT，
             * 或者为错误描述，则结束轮询。
             */
            const taskIdParams = {
              TaskId: taskId,
            };

            const timer = setInterval(() => {
              client
                .getTaskResult(taskIdParams)
                .then(response => {
                  console.log('识别结果查询响应：');
                  console.log(response);
                  const statusText = response.StatusText;
                  if (statusText == 'RUNNING' || statusText == 'QUEUEING') {
                    // 继续轮询，注意间隔周期。
                  } else {
                    if (
                      statusText == 'SUCCESS' ||
                      statusText == 'SUCCESS_WITH_NO_VALID_FRAGMENT'
                    ) {
                      console.log('录音文件识别成功：');
                      let sentences = '';
                      for (const s of response.Result.Sentences) {
                        sentences += s.Text;
                      }
                      console.log(response.Result);
                      resolve(sentences);//**重点**//
                      // return sentences;
                    } else {
                      console.log('录音文件识别失败!');
                    }
                    // 退出轮询
                    clearInterval(timer);
                  }
                })
                .catch(error => {
                  console.error(error);
                  // 异常情况，退出轮询。
                  clearInterval(timer);
                });
            }, 10000);
          })
          .catch(error => {
            console.error(error);
          });
      });
    }
    return await getWords();//返回前端，翻译结果
```



> 另外记录一件事情，左侧单元图标地址：https://fontawesome.com/v4.7.0/icons/