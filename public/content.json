{"meta":{"title":"Zehai'blog","subtitle":null,"description":"会做饭的厨子","author":"Zhang Zehai","url":"http://zehai.info","root":"/"},"pages":[{"title":"Docker","date":"2020-02-11T01:51:34.000Z","updated":"2020-02-11T03:55:05.697Z","comments":true,"path":"Docker/index.html","permalink":"http://zehai.info/Docker/index.html","excerpt":"","text":"hello worlddokcer containerdocker imagedocker swarm"},{"title":"ComputerOS","date":"2019-04-21T04:15:39.000Z","updated":"2019-04-24T14:49:55.013Z","comments":true,"path":"ComputerOS/index.html","permalink":"http://zehai.info/ComputerOS/index.html","excerpt":"","text":"conceptOS（Operating System）是控制和管理整个计算机系统的硬件和软件资源，合理调度计算机的工作和资源分配，提供给用户和其他软件接口和环境。 四大特征 并发 共享 虚拟 异步 并发概念：指多个事件在同一时间间隔内发生，宏观上是同时发生，微观上是交替发生（区别于并行：多个事件同一时刻发生） 共享分为：互斥共享，同时共享 虚拟把物理上的实体变为若干个逻辑上对应物，如4GB内存可以同时运行大于4G的软件（时分复用或者空分复用） 异步多个程序并发执行，断断续续同步推进 运行机制与体系结构运行机制指令=特权指令+非特权指令 特权：如内存清零 非特权：如普通运算 CPU=用户态（非核心）+核心态（核心+非核心） 程序状态寄存器PSW，0为用户态，1位核心态 内核： 时钟管理（计时） 中断处理 原语 系统资源管理（进程，存储器，设备管理） 大内核：高性能但维护麻烦 微内核:结构清晰但切换开销大 中断和异常中断是CPU进入核心态，当前进程暂停，而核心态–&gt;用户态只需要通过PSW的特权指令就可以进入 中断=内中断+外中断 内中断：异常，例外，陷入 指令中断 硬件故障（如缺页），软件中断（如编程语法错误） 外中断：外设请求，人工干预 系统调用 设备管理 文件管理 进程控制 进程通信 内存管理 传递系统调用参数–&gt;限制性陷入指令（用户态）–&gt;执行系统调用相应服务程序（核心态）–&gt;返回用户程序 陷入指令在用户态执行，执行陷入指令后立即引发一个内中断，从而CPU进入核心态 库函数应用程序–&gt;库函数–&gt;系统调用 库函数目的：高级开发，更方便系统调用 进程why: what:是运行过程，是系统进行资源分配和调度的最小单位 进程段=程序段+数据段+PCB PCB=PID+UID+进程控制管理信息（进程状态，优先级）+资源分配（程序段指针，数据段指针，键盘鼠标）+处理机信息（寄存器值） feature: 动态性 并发性 独立性 异步性 组织方式： 链接方式（执行指针，就绪指针，阻塞指针） 索引方式（执行指针，就绪指针，索引指针） 五种状态 运行 就绪 阻塞 创建 终止"},{"title":"Java","date":"2020-01-29T14:12:19.000Z","updated":"2020-01-30T05:33:57.546Z","comments":true,"path":"Java/index.html","permalink":"http://zehai.info/Java/index.html","excerpt":"","text":"[TOC] 面向对象概念面向对象（Object Oriented），对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。换句话说，对象是真是存在内存的，实例化的类，比如你想要的粥，类就是锅里的粥，实例化就是盛出来放进碗中，而对象就是一碗粥，真实存在，可以被你操控，又或者你女朋友A是你择偶标准（类）实例化出来的对象，真实存在，但择偶标准并不真实存在 对象VS过程面向过程编程更加注重一个类解决一个问题，是一个解决方案，而不需要你去考虑这个对象具体怎么实现的 换句话说，面向过程就是生产一辆汽车，面向对象就是直接买一辆汽车开，你可以把汽车销售商理解为一个对象的提供商，为你提供服务。 三大核心三大核心都是尽最大的可能复用代码 继承定义类的基石（共同的属性和方法） 避免子类重复定义，单继承（只能继承一次）！ 子类拥有父类的所有属性和方法（除了private修饰的属性不能拥有） 目的：代码复用 重载：同名函数不同参数 重写：重写方法实现方式（子类个性化） final的几个问题： final修饰的类不允许继承 final修饰的方法不允许重写 final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的初始化属性必须有值，或在构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，且初始化之后就不能改了，只能赋值一次 final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为常量 super的几个问题： 访问父类对象，如：super.age,super.eat() 子类构造的过程调用父类的构造方法，默认调用无参构造方法 封装（set/get）封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 多态多态就是同一个接口，使用不同的实例而执行不同操作 多态性是对象多种表现形式的体现。 现实中，比如我们按下 F1 键这个动作： 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档； 如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。 基本数据类型内置数据类型 byte（-128~127即2^7,默认0） short（16位，默认0） int(32位，默认0) long(64位，默认0L) float（32位，默认0.0f） double(64位，默认0.0d) boolean(1位默认false) char（16位0~65535） 引用数据类型引用为指针的另一种变种，引用类型指向一个对象，数组 常量final修饰 拆箱和装箱why 数字字符日期等基本类型封装成对象方便处理，但是对于CPU来说，一个完整的对象需要很多的指令，对于内存来说，有需要很多的内存，性能自然很低，所以设计装箱和拆箱，是的基本类型在编程中当做非对象处理，在另外场合有当做对象处理 int的自动拆箱和装箱只在-128到127范围中进行，超过该范围的两个integer的 == 判断是会返回false的。 变量存储方式基本类型-&gt;栈内存 引用类型-&gt;堆内存 String和包装类string基础字符串属于对象,char属于基本类型，String greetings=“hello,world” 如果如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。通过append可以直接修改，Stringbuilder不是线程安全的但是又速度优势，建议使用，StringBuffer是线程安全 appen追加 reverse反转 delete移除 insert将int插入 replace替换等 String是final class不可变不可继承，由于不可变，所以拼接字符串会有很多中间无用的对象，所以会影响性能，但不影响正常小批量的字符串拼接 StringBuffer是解决上述问题的方案，提供append和 add方法，拼接至尾部，他的本质是一个县城安全的可修改的字符序列，添加了synchronized，但也付出了性能代价 很多情况下字符串拼接无需线程安全，则可以使用StringBuilder StringBuffer 和 StringBuilder 二者都继承了 AbstractStringBuilder ，底层都是利用可修改的char数组(JDK 9 以后是 byte数组)。 string基本用法 String s1 = “mpptest” String s2 = new String(); String s3 = new String(“mpptest”) “==”判断引用内容，equals判断引用地址 string类源码1234567891011public void intern () &#123; //2：string的intern使用 //s1是基本类型，比较值。s2是string实例，比较实例地址 //字符串类型用equals方法比较时只会比较值 String s1 = \"a\"; String s2 = new String(\"a\"); //调用intern时,如果s2中的字符不在常量池，则加入常量池并返回常量的引用 String s3 = s2.intern(); System.out.println(s1 == s2);//false System.out.println(s1 == s3);//true&#125; (此处待补充) String和JVM Java栈（线程私有） 每个Java虚拟机线程都有自己的Java虚拟机栈，Java虚拟机栈用来存放栈帧，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 Java堆（线程共享）存放所有对象 方法区（线程共享） 方法区在虚拟机启动的时候被创建，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容、还包括在类、实例、接口初始化时用到的特殊方法。在JDK8之前永久代是方法区的一种实现，而JDK8元空间替代了永久代，永久代被移除，也可以理解为元空间是方法区的一种实现。 常量池（线程共享） 常量池常被分为两大类：静态常量池和运行时常量池。 静态常量池也就是Class文件中的常量池，存在于Class文件中。 运行时常量池（Runtime Constant Pool）是方法区的一部分，存放一些运行时常量数据。 String为什么不可变变量在栈中，数据本身在堆中，引用不可变 String常用工具apache-commons final关键字Java类和包抽象类和接口代码块和代码执行顺序自动拆箱装箱Class类和Object类异常回调反射泛型枚举类注解IO流多线程内部类javac和javapjava8新特性类和包序列化和反序列化继承封装多态实现原理"},{"title":"RocketMQ","date":"2019-05-06T09:30:12.000Z","updated":"2019-05-06T09:30:36.814Z","comments":true,"path":"RocketMQ/index.html","permalink":"http://zehai.info/RocketMQ/index.html","excerpt":"","text":""},{"title":"Node.js","date":"2019-04-05T02:49:57.000Z","updated":"2020-01-31T02:16:29.954Z","comments":true,"path":"Nodejs/index.html","permalink":"http://zehai.info/Nodejs/index.html","excerpt":"","text":"what Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. Node是JavaScript运行环境 事件驱动，非阻塞IO模型 使用npm管理包 基本原理 Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 Chrome 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。 Event Loop 事件循环（由 libuv 提供） Thread Pool 线程池（由 libuv 提供） 带来的好处 用户体验 资源分配 Blocking 与Non-blocking大量诸如IO，锁操作会造成堵塞，node标准库中所有IO都提供了非阻塞的一步版本，接受回调函数 回调函数可以放入底层线程池操作，不阻塞主线程 可以自定义回调函数，处理返回结果 我们可以直接比较一下阻塞和非阻塞的代码： 123456789//blocking 且如果错误需要catch否则程序会**崩溃**const fs = require('fs');const data = fs.readFileSync('/file.md'); // blocks here until file is read//non-blockingconst fs = require('fs');fs.readFile('/file.md', (err, data) =&gt; &#123; if (err) throw err;&#125;);//执行第6行后，放进队列，开始执行下面的业务数据 并发和吞吐量Node起服务大概会启动一个进程，包含7个线程， 1 个 Javascript 执行主线程；1 个 watchdog 监控线程用于处理调试信息；1 个 v8 task scheduler 线程用于调度任务优先级，加速延迟敏感任务执行；4 个 v8 线程（可参考以下代码），主要用来执行代码调优与 GC 等后台任务；以及用于异步 I / O 的 libuv 线程池。 并发指的是执行完其他工作后，事件循环执行回调的能力，高并发原理：如一个请求50ms请求，其中45ms都在数据库，那么我可以5ms处理完，推入队列，其余时间继续响应其他请求。 eventloop是JS的特性，在其他语言中，会创建线程来处理并发工作（比如同时两个请求，创建两个线程来处理，但是他们之间可能访问数据会加锁，如果有100个请求，访问同一个数据，加个锁，99个请求都只能等着了） 混合阻塞代码和非阻塞代码处理io应该避免如下写法： 1234567const fs = require('fs');fs.readFile('/file.md', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);fs.unlinkSync('/file.md');//unlink first//应该将unlink写入回调函数 EventLoopwhateventloop（事件循环）给予node非阻塞IO的优势，尽管JS是单线程 由于大多数内核支持多线程，他们可以再后台执行多个任务，当某个任务完成的时候，内核会告诉node，以便将callback添加到poll队列来执行 Explained当node启东时，他会初始化eventloop，处理输入的script(或者放入REPL)，这些script可以执行异步API调用，定时器，或者调用process.nextTick(),然后开始处理事件循环 其中每个矩形被称作phase（个人理解：阶段） 每一个phase都有一个有callbacks等待执行的FIFO的队列，尽管每个phase都有自己特殊的地方，但是通常，当eventloop执行到某一个phase时候，他将执行该阶段特定的操作，然后调用queue里面的callback function直到队列为空或者达到该phase最大的回调执行数量。 timers：setTimeout() and setInterval() pending callbacks: 执行推迟到下一个tick的IO回调 idle, prepare: 内部使用 poll: 接收新的IO event，执行与IO相关的回调（关闭回调，计时器回调，setImmediate）(该phase可能会block) check: setImmediate() close callbacks: 关闭回调, 如 socket.on(&#39;close&#39;, ...). 由于执行某一个phase都可能新增更多的操作任务，一些新的event也会进入poll 队列中排队，因此可在处理轮询事件时候将poll event排队，使得长时间运行的回调也可以使轮询阶段运行的时间比计时器的阈值长很多。 待更新计时器目的：设定时间段后执行函数，直接使用无需require 使用nodejs控制时间连续性settimeout异步编程Buffer The Buffer class was introduced as part of the Node.js API to enable interaction with octet streams in TCP streams, file system operations, and other contexts. 原因：应用需要 处理网络协议 操作数据库 处理图片 接受上传文件等 处理大量二进制数据，JavaScript自由的字符串不能满足这些要求 结构与C++结合：node_buffer–&gt;Buffer/SlowBuffer 也就是JavaScript的Buffer或者SlowBuffer依赖于C++的内建模块，buffer内存不归v8管理，是堆外内存 声明123456const str=\"helloworld\"const buf=new Buffer(str,'utf-8')console.log(buf)//=&gt;&lt;Buffer xx xx xx&gt;16进制数字buf[22]=10//只能赋值0-255的数值，否则会取余256 内存分配Node的C++层面实现内存申请，在JavaScript中分配内存的策略，Node采用slab的动态内存管理机制，slab的3种状态 full：完全分配 partial：部分分配 empty：没有分配 Buffer.poolSize=8*1024，即以8kb为大小Buffer的分界，小于8Kb拼单，大于8kb分配大的slab被大buffer独占 转换可以转换的类型 asc2 utf-8 utf-16LE/UCS-2 Base64 Binary Hex 采用new Buffer(str,[encoding]),默认utf-8 buf.write(string,[offset],[length],[encoding])默认utf-8 buf.toString([encoding],[start],[end])默认utf-8 拼接性能性能大概是字符串的一倍 EventLooplibuv介绍page"},{"title":"Redis","date":"2019-11-17T07:49:54.000Z","updated":"2019-11-22T08:46:07.868Z","comments":true,"path":"Redis/index.html","permalink":"http://zehai.info/Redis/index.html","excerpt":"","text":"首先感谢掘金@敖丙的《吊打面试官》系列的启发 whatredis是一个缓存，基于内存操作数据，算是数据库的小弟，帮助数据库挡掉一些经常查询的内容，避免扫描库（你要知道有些查询要关联很多表，虽然你可能只查一条数据，但可能要要执行2-3秒，在高并发下是致命的），主要用的Redis以及Java的Memcached，两者各有特点，但市场倾向于Redis 知识点罗列Redis 数据结构： 类型 作用 示例 String 保存字符串 session Hash key-value 计数器 List 数组 数组类型数据 Set 去重数组 自动去重 SortedSet 去重排序数组 微博热搜榜单 HyperLog Geo Pub/Sub Redis modules 暴露接口自定义redis模块，自定义数据结构（json支持，对图数据库支持，匹配添加正则功等），访问redis数据空间，实现阻塞命令，动态链接加载模块，编写神经网络模块等 * 官方有文档，待学习，应用如：BloomFilter,redisSearch,redis-ML 内存清理待补充 分布式锁 目的：redis cluster时候保证一个数据同时只有一个实例在读/写 实现：zookeeper或者setnx争抢锁，expire释放，类似进程锁 持久化 持久方式 实现原理 应用场景 RDB（） 全量 冷备份，耗时 AOF 增量 实时增量（sync属性配置同步时间） 混合使用 全量启动，AOF恢复近期数据 寻找key 1.keys-会阻塞-无重复项 2.scan-不阻塞-会有重复项 异步队列实现 1.rpush生产，lpop消费 2.sleep稍后重试，blpop休息直到消息来 3.应用场景：曾经调用仓库系统发货，仓库系统库存1一分钟更新一次，所以将发货数据推入队列中 4.pub/sub可以实现一次生产多次消费，高级的MQ解决意外情况 5.延时队列，sortedset，时间戳做score，内容做key调用zadd生产，zrangebysccore获取N秒前消息轮询消费 pipeline 1.多次IO一次返回 2.压测 同步机制 1.主从同步 2.从从同步 集群 redis sentinal高可用，master宕机选新头儿 redis cluster 扩展性，多个实例 BloomFilter 布隆过滤器，常用用于避免缓存击穿 实现原理：二进制向量和随机映射函数 作用：检查元素是否在合集中 工作流程：布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。"},{"title":"structure","date":"2019-03-14T09:21:10.000Z","updated":"2019-04-07T02:54:32.849Z","comments":true,"path":"Structure/index.html","permalink":"http://zehai.info/Structure/index.html","excerpt":"","text":"线性表LinkedList线性表=数组+链表 线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。 顺序存储 链式存储 典型 数组 链表 物理连续性 连续 分开，靠指针桥接 插入、删除复杂度 O(n) O(1) 查找复杂度 O(1) O(n) 链表=单向链表+双向链表+循环链表等等（为了解决查找复杂度为O（n）的情况，即每次都要从头开始遍历，所以有了双向链表，进一步的把收尾连起来循环，是双向链表的一个进化，能更好的遍历以及利用空间） 12345struct ListNode &#123; int val; ListNode *next; ListNode(int val,ListNode *next=NULL):val(val),next(next)&#123;&#125;&#125;; Queue 队列（默认单队列） 循环队列（通过取余，形成逻辑上闭环）rear = (rear - size) % size 不以 front = rear 为放满标志，改为 (rear - front) % size = 1 Java-Collection=set+list+queue Set(HashSet,TreeSet) 无重复元素的数组 HashSet 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中的位置； TreeSet 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序； ##List 在 List 中，用户可以精确控制列表中每个元素的插入位置，另外用户可以通过整数索引（列表中的位置）访问元素，并搜索列表中的元素。 与 Set 不同，List 通常允许重复的元素。 另外 List 是有序集合而 Set 是无序集合。 ArrayList:数组队列，动态，线程不安全 vector：矢量队列，和数组类似，线程安全 linkedList：双向链表 TreeBST二叉查找树：binary search tree 左子树上所有结点的值均小于或等于它的根结点的值 右子树上所有结点的值均大于或等于它的根结点的值 左、右子树也分别为二叉排序树(regression) 应用：二分查找O(logn),查找次数等于树的高度 缺点：新插入节点的时候，因为要旋转复杂度较高（引入红黑树的法则降低旋转） RBT（red black tree）原名：平衡二叉B树（symmetric binary B-trees） feature： 每个节点都只能是红色或者黑色 根节点是黑色 每个叶节点（NIL节点，空节点）是黑色的。 如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 红黑树带来的优势： 红黑树根到椰子的最长路径不会超过最短路径的2倍 插入或删除，通过feature来调整结构（有的时候不需要调整） 插入默认是红色，调整包括变色和旋转 应用于JDK，Collection中的TreeMap和TreeSet，HashMap（JDK1.8之后用，且阈值大于8时候才切换到红黑树，之前用的是拉链法）"},{"title":"Schedule","date":"2019-04-06T14:57:15.000Z","updated":"2019-04-06T15:03:43.535Z","comments":true,"path":"Schedule/index.html","permalink":"http://zehai.info/Schedule/index.html","excerpt":"","text":"更新Interview中JS的去重 更新Structure中的二叉树"},{"title":"System","date":"2019-03-14T09:20:32.000Z","updated":"2019-03-14T09:20:32.915Z","comments":true,"path":"System/index.html","permalink":"http://zehai.info/System/index.html","excerpt":"","text":""},{"title":"about","date":"2019-03-11T15:11:47.000Z","updated":"2020-01-31T03:18:07.433Z","comments":true,"path":"about/index.html","permalink":"http://zehai.info/about/index.html","excerpt":"","text":"联系方式 邮箱：zehaizhang@aliyun.com 个人信息 章泽海/男/1995 本科/北京城市学院-信息学院 工作年限：1年 技术博客：http://zehai.info Github：http://github.com/ShawnGoethe 期望职位：NodeJS程序员，数据分析 期望薪资：税前月薪10k~12k，特别喜欢的公司可例外 期望城市：北京 自我评价在凌众时代参与羽扇广告优化系统开发，实习工作于金山等互联网公司，参与秀堂项目开发；熟悉软件后台开发，擅长Node.js、Java、MySQL、Mongo及Redis，掌握Vue、Express、Egg.js，consul，spring boot开发技能，拥有CSDN原创博客60余篇，完成LeetCode，蓝桥算法题目两百余题，使用Git，SVN管理项目，熟悉Linux操作及bash编程；具备基本Supervised Learning以及scrapy能力，在CNode，V2EX，Medium解决问题和交流技术；多次获得国家奖学金及省部级赛事奖项，担任校会学习部长，具备优秀的学习能力和团队合作能力。 工作经历云丁科技 （ 2019年4月 ~ 2020年2月 ）扫垃圾顺便开发 凌众时代 （ 2018年6月 ~ 2018年9月 ）参与羽扇系统、渠道管理系统等项目开发工作，羽扇系统为人工智能广告优化投放系统，个人负责后端功能的开发，通过Egg.js，EJS，PostgreSQL，MongoDB，实现了关键词价格分析对比，个人账户日报生成，分时段计划展显销数据分析，数据导出等功能。渠道管理系统是渠道提交新需求和修改需求的系统，使用express，PostgreSQL开发，个人负责所有后端功能搭建，向前端提供API，系统具备新增需求，上传压缩包文件，自动生成链接，邮件提醒，需求导出等功能，使用Nginx进行发布 金山软件 （ 2017年12月 ~ 2018年5月 ）参与金山办公WPS、秀堂等项目开发工作，通过JavaScript、HTML5、LESS及Vue，Express框架，联合Redis缓存，MongoDB，Git版本管理，实现投票防刷，互动视频，画册分类功能，完成防止刷票，视频播放，画册快速检索的功能，已经生产环境。 教育经历## 北京城市学院 （ 2014年9月 ~ 2018年6月 ）软件工程 统招开源项目和作品开源项目 chum：项目的简要说明，Star和Fork数多的可以注明 neews：项目的简要说明，Star和Fork数多的可以注明 技术文章 cccc dddd 技能清单以下均为我熟练使用的技能 Web框架：ThinkPHP/Yaf/Yii/Lavaral/LazyPHP 自建B树&lt; &lt; &lt;欢迎点击"},{"title":"categories","date":"2019-03-22T13:17:40.000Z","updated":"2019-03-22T13:18:02.572Z","comments":true,"path":"categories/index.html","permalink":"http://zehai.info/categories/index.html","excerpt":"","text":""},{"title":"Interview","date":"2019-04-06T14:55:46.000Z","updated":"2020-02-21T08:23:42.228Z","comments":true,"path":"Interview/index.html","permalink":"http://zehai.info/Interview/index.html","excerpt":"","text":"JS去重 排序，遍历顺序比较，不同就push到新数组 1234567891011let c=[1,2,3,4,5,6,1,2,3]function unique(arr)&#123; let Arr=arr.sort() let b=[] for(let i=0;i&lt;Arr.length;i++)&#123; if(Arr[i]!==Arr[i+1])&#123; b.push(Arr[i]) &#125; &#125; return b&#125; indexOf遍历 12345678910let c=[1,2,3,4,5,6,1,2,3]function unique(arr)&#123; let b=[] for(let i=0;i&lt;arr.length;i++)&#123; if(b.indexOf(arr[i])==-1)&#123; b.push(arr[i]) &#125; &#125; return b&#125; map()/forEach() set 123456let c=[1,2,3,4,5,6,1,2,3]function unique(arr)&#123; let b=new Set(arr) let c=Array.from(b) return c&#125; 递归regressionFibonacci1234567891011121314151617181920212223242526//迭代，number=40,time=1msint Fibonacci(int number) &#123; if (number &lt;= 0) &#123; return 0; &#125; if (number == 1 || number == 2) &#123; return 1; &#125; int first = 1, second = 1, third = 0; for (int i = 3; i &lt;= number; i++) &#123; third = first + second; first = second; second = third; &#125; return third;&#125;//regression n=40,time=272mspublic int Fibonacci(int n) &#123; if (n &lt;= 0) &#123; return 0; &#125; if (n == 1||n==2) &#123; return 1; &#125; return Fibonacci(n - 2) + Fibonacci(n - 1);&#125; 变种：青蛙跳台阶数据结构链表翻转链表有序链表合并123456789101112131415public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125; 堆和队列用队列实现堆栈用堆栈实现队列SortingHTTPS的认证过程 TCP/IP三次握手 Java基础HashMap实现原理HashMap是拉链(Hash再散列的一种方式)的一种实现方式（JDK1.7之前，以及1.8以后，阈值小于8），左边一列为数组（位桶数组），右边为链表（Entry链，通过equal判断） Hashmap在JDK1.8，阈值大于8后，采用红黑树 1234567891011121314151617static final class TreeNode extends LinkedHashMap.Entry &#123; TreeNode parent; // 父节点 TreeNode left; //左子树 TreeNode right;//右子树 TreeNode prev; // needed to unlink next upon deletion boolean red; //颜色属性 TreeNode(int hash, K key, V val, Node next) &#123; super(hash, key, val, next); &#125; //返回当前节点的根节点 final TreeNode root() &#123; for (TreeNode r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; HashMap，HashTable，ConcurrentHashMap！！可能有错，还未梳理完成 hashmap hashtable concurrentHashMap 底层 数组+链表 数组+链表 数组+链表 线程安全 √ × × null kv不能为空 kv可以为空 初始大小 11 16 扩容 2*old+1 old*2 Redis使用场景 缓存 登录session feature： 基于内存（快的原因） 数据结构简单（set hash list zset） 单线程，避免不必要的上下文切换和竞争条件，没有锁，多路I/O复用，非阻塞（和Nodejs一样） 分布式Kafka优缺点 高吞吐量的消息队列，基本组件：消费者，生产者，node节点等 副本……………… 概念幂等性 数学上，对于x，有f(x)=f(f(x))，则成为幂等性 在分布式环境下，表示对同样的请求，在一次或者多次请求的情况下，对系统的使用资源是一样的，保证失败重试不会导致提交两次 堆栈内存堆内存：是线程共享的,new 栈内存：线程私有的,基本类型的变量和对象的引用变量 数据库事务Transaction是一个操作序列，不可分割的工作单位，以begin transaction开始，以rollback/commit结束 特性 Desc 原子性Atomicity 全对或回滚 一致性Consistency 多次事务结果相同 隔离性Isolation 事务间互不影响 持久性Durability 一但成功即永久 并发一致性问题 丢失修改，后事务对一个未完成事务修改覆盖 脏读，后事务对一个未完成事务修改过的数据读 不可重复读，后事务读取过程中数据被修改 幻读，类似不可重复，区别于是插入操作修改 四种隔离级别 未提交读 提交读 可重复读（MYSQL默认隔离级别） 可串行化（事务全部串行，效率低） 乐观锁&amp;悲观锁悲观锁：先锁再操作，适合数据修改频繁场景 乐观锁：先读，读的时候在判断是否有事务再更新，有则重读（通过加版本号或者时间戳作为字段为判断依据，缺点就是每次数据更新都需要更新这个字段） 封锁类型 排它锁X 共享锁S 只读共享 意向锁 三级封锁协议（待补充，不重要） 一级，X 二级 三级 数据库索引的实现原理（B+树）innoDB中使用的B+树 IO次数少，B+树中间节点存储索引，数据在叶子节点中 查询B树要遍历，B+只需要遍历叶子节点 why 选择B+ 效率比O(1)好 B树索引支持大小比较，范围查找 innodb和myISAM区别 innodb支持事务 myisam仅有表级锁，innodb表+行锁 innodb支持外键 innodb在线热备份 数据库优化SQL优化该部分基本需要遵守一些准则，合理利用索引 避免!=,&gt;,&lt;,null的判断（索引失效） 返回必要的列，减小select * (graphQL解决方案) Limit限制 索引优化（主） 建立合适的索引，不能太多，也不能太少（太少全表检索用不到索引，太多就冗余，索引可能比数据还多？） 表结构优化 范式遵循（默认3） 选择合适类型，尽可能不要存储null 水平切分，根据哈希取模，将一个表水平切分，当一个表中数据增多时，sharding，将数据分不到集群的不同节点上 垂直切分，将不常用的字段独立放一个表中 配置优化 增加TCP支持的队列 MYSQL配置缓存池大小 etc 硬件优化（次） 磁盘性能 CPU 内存 主从复制Replication将数据从一个mysql中复制到其他服务器中，默认异步同步 主服务器binary log dump线程将数据更改写入日志 从服务器IO线程读取数据修改日志，写入本地relaylog 从服务器SQL线程，读取relaylog解析并执行 why选择主从复制 读写分离，主写从读 缓解锁竞争 从使用myisam提升查询性能 数据实时备份 降低单个IO访问频率（显然） 索引分类 普通索引 唯一索引，索引值唯一，可空 主键索引，唯一不可空 复合索引 覆盖索引 聚集索引 分区索引 虚拟索引 MVCCmulti-version concurrency control 每行记录后面保存两个隐藏的列用来存储版本号和删除版本号 创建版本号：创建数据时的事务版本号 删除版本号：同上 范式依次严格 第一范式：不存在可分的列 第二范式：主键 第三范式（默认）外键 第 表连接方式内连接：满足连接条件的行组合起来（交集） 自然连接 等值连接 外连接：左连接，右连接，全连接 交叉连接：笛卡尔积，即m*n 存储过程存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。 想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。 优点： 预先编译，效率高 封装操作减少网络通信 可复用 安全性高，可以让低权限用户直接调用 易维护 缺点（可以忽略）： 移植性差 调试复杂 修改复杂 删除命令 delete删除全表数据或部分数据，触发日志，可还原 truncate清空所有数据不可回滚，自增重置为1，无日志 drop删除数据，表，索引，约束不能回滚，无日志 视图取出来的数据可视化，操作不影响数据库中数据 1234CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition 游标定位查询返回结果集中的特定行，以对特定行进行操作，分普通游标和滚动游标（了解，应用不多） ACID特性原子性： 一致性： 隔离性： 持久性： 如何rollback写入前会有redo log和undo log，如果失败会逆向还原到事务开始之前 灵魂拷问Java多线程 线程池的原理，为什么要创建线程池？ 线程的生命周期，什么时候会出现僵死进程； 什么实现线程安全，如何实现线程安全； 创建线程池有哪几个核心参数？如何合理配置线程池的大小？ synchronized、volatile区别、synchronized锁粒度、模拟死锁场景、原子性与可见性； JVM相关 JVM内存模型，GC机制和原理；GC分哪两种；什么时候会触发Full GC？ JVM里的有几种classloader，为什么会有多种？ 什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；(这个我真的不会…) 什么情况下我们需要破坏双亲委派模型； 常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？ JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的； Java扩展 红黑树的实现原理和应用场景； NIO是什么？适用于何种场景？ Java9比Java8改进了什么； HashMap内部的数据结构是什么？底层是怎么实现的？ 说说反射的用途及实现，反射是不是很慢，我们在项目中是否要避免使用反射； 说说自定义注解的场景及实现； List和Map区别，Arraylist与LinkedList区别，ArrayList与Vector 区别； Spring Spring AOP的实现原理和场景；（应用场景很重要） Spring bean的作用域和生命周期； Spring Boot比Spring做了哪些改进？Spring 5比Spring4做了哪些改进；（惭愧呀，我们还在用Spring4，高版本的没关心过） Spring IOC是什么？优点是什么？ SpringMVC、动态代理、反射、AOP原理、事务隔离级别； 中间件 Dubbo完整的一次调用链路介绍； Dubbo支持几种负载均衡策略？ Dubbo Provider服务提供者要控制执行并发请求上限，具体怎么做？ Dubbo启动的时候支持几种配置方式？ 了解几种消息中间件产品？各产品的优缺点介绍； 消息中间件如何保证消息的一致性和如何进行消息的重试机制？ Spring Cloud熔断机制介绍； Spring Cloud对比下Dubbo，什么场景下该使用Spring Cloud？ 数据库 锁机制介绍：行锁、表锁、排他锁、共享锁； 乐观锁的业务场景及实现方式； 事务介绍，分布式事物的理解，常见的解决方案有哪些，什么事两阶段提交、三阶段提交； MySQL记录binlog的方式主要包括三种模式？每种模式的优缺点是什么？ MySQL锁，悲观锁、乐观锁、排它锁、共享锁、表级锁、行级锁； 分布式事务的原理2阶段提交，同步异步阻塞非阻塞； 数据库事务隔离级别，MySQL默认的隔离级别、Spring如何实现事务、 JDBC如何实现事务、嵌套事务实现、分布式事务实现； SQL的整个解析、执行过程原理、SQL行转列； Redis Redis为什么这么快？redis采用多线程会有哪些问题？ Redis支持哪几种数据结构； Redis跳跃表的问题； Redis单进程单线程的Redis如何能够高并发? Redis如何使用Redis实现分布式锁？ Redis分布式锁操作的原子性，Redis内部是如何实现的？"},{"title":"KnowledgeTree","date":"2020-01-18T15:03:00.000Z","updated":"2020-03-02T06:03:03.074Z","comments":true,"path":"KnowledgeTree/index.html","permalink":"http://zehai.info/KnowledgeTree/index.html","excerpt":"","text":"[TOC] 数据结构队列队列有两种实现方式，一个是连续空间的数组（无需空间存指针，但是扩容只能整体复制到新的大数组，而且线性，基本首位相连使用），一种是链表形态（需要额外空间存指针，但扩容直接追加，以及增删元素不需要动其他元素） Java中队列分为阻塞和非阻塞两种，顾名思义，阻塞队列是一个一个顺序执行，非阻塞队列是并发的 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 阻塞队列的DelayQueue可以做成延时队列，可以见这篇文章→:关于Promise的思考，原本Node需要借助Promise循环一次只取一个特性的延时队列，可以使用delayQueue直接求解 队列除了数组，链表的区别，阻塞 分类，还可以安全区分，简单来说就是多线程下并发读写是否会出问题。 集合Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 hashset hashtable treeset 链表、数组链表List数组Array其实和队列queue是一种东西，只是队列（或者堆栈）是特殊化的链表/数组，他们限制了元素的进出方式，解决了顺序处理/递归压栈的问题。 不过链表，数组区别于set，前者是有序的，set是无序不重复的 List主要分为3类，ArrayList， LinkedList和Vector，都继承自Collection，只是各自有自己的特性的方法 ArrayList是一个数组实现的列表，由于数据是存入数组中的，所以它的特点也和数组一样，查询很快，但是中间部分的插入和删除很慢 LinkedList还是一个双向链表 Vector就是ArrayList的线程安全版，它的方法前都加了synchronized锁，其他实现逻辑都相同。如果对线程安全要求不高的话，可以选择ArrayList，毕竟synchronized也很耗性能 字典、关联数组栈树树结构是一对多的数据结构 他的应用包括：红黑树，数据库存储，磁盘文件存储等 二叉树每个节点最多有两个叶子节点 完全二叉树平衡二叉树二叉查找树BST红黑树B系列树B-树是一种多路搜索树 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 自动层次控制 B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点 B+ 树通常用于数据库和操作系统的文件系统中 B* 树 是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针； LSM树LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。 Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet常用算法排序+查找布隆过滤器字符串比较DFS+BFS贪心回溯剪枝动态规划朴素贝叶斯推荐算法推荐算法通常被分为四大类 协同过滤推荐算法 基于内容的推荐算法 混合推荐算法 流行度推荐算法 最小生成树最短路径算法并发概念多线程线程安全事务锁操作系统原理CPU进程线程协程通信Linux设计模式六大原则 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式应用场景单例模式单例模式：单例模式的意思就是只有一个实例。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 单例模式有三种： 懒汉式单例：第一次调用初始化，但初始化时需加锁 12345678910public class Singleton&#123; private static Singleton singleton; private Singleton &#123;&#125;; public static synchronized Sigleton getInstance&#123; if(singleton ==null)&#123; singleton=new Singleton(); &#125; retrun singleton; &#125;&#125; 饿汉式单例:类加载初始化，后续一直存在，浪费内存 1234567public class Singleton&#123; private static final Singleton SINGLETON=new Singleton(); private Signleton()&#123; &#125; public static Signleton getInstance()&#123; retrun SINGLETON; &#125;&#125; 登记式单例:内部类在外部调用加载，无需用锁 123456789public class Singleton&#123; private Sigleton()&#123;&#125; public static Singleton getInstance()&#123; retrun Holder.SINGLETON; &#125; private static class Holder&#123; private static final Singleton SINGLETON=new Singleton(); &#125;&#125; 责任链模式MVCIOCAOPUML微服务运维监控APM统计分析持续继承CI/CDJenkins环境分离自动化运维Ansiblepuppetchef测试TDD理论单元测试压力测试全链路压测A/B、灰度、蓝绿测试##虚拟化 KVMXenOpenVZ容器化Docker云技术OpenstackDevOps文档管理中间件Web ServerNginxOpenRestyTengineApache HttpdTomcatJetty缓存本地缓存客户端缓存服务端缓存Web缓存MemcachedRedis架构回收策略Tair消息队列消息总线消息顺序RabbitMQRocketMQActiveMQKafkaRedisZeroMQ定时调度单机定时调度分布式定时调度RPCRPC = Remote Procedure Call 目的：调用远程服务接口如同调用本地（方便本地开发，及服务间调用） 构成：server，client，registry（Redis,zookeeper,consul,more） 技术：动态代理（CgLib,Javasisit），序列化，NIO（Netty），注册中心 流程： clent调用本地方法 client stub，封装成为网络传输消息体 client stub 从registry获取地址发送 server解码，调用本地方法，返回到server stub server stub 结果打包返回给client client解码，获取结果 优秀框架： 框架 简介 开发语言 分布式 多序列化框架支持 Dubbo 阿里，Java高性能优秀的服务框架 java √ √ Motan 微博，Java框架 java √ √ rpcx Go go √ √ gRPC Google，基于protoBuf序列化，不是分布式 多语言 × × thrift Apache，跨语言 多语言 × × DubboThriftgRPC数据中间件Sharding Jdbc日志系统日志搜集配置中心API网关网络协议OSITCPIPHTTPHTTP2HTTPS网络模型EpollJava NIOKqueue连接和短连接框架零拷贝序列化序列化是二进制协议 Hessian Protobuf Hessianprotobuf数据库搜索引擎性能大数据安全常用开源框架分布式设计设计思想+开发模式项目管理通用业务术语技术趋势政策法规架构师素质团队管理资讯技术资源"},{"title":"QS2019","date":"2019-03-13T06:11:05.000Z","updated":"2019-03-13T06:32:01.550Z","comments":true,"path":"qs2019/index.html","permalink":"http://zehai.info/qs2019/index.html","excerpt":"","text":"top 18 No school_name 中文名 1 MIT 麻省理工学院 2 Stanford Uni 斯坦福大学 3 Harvard Uni 哈佛大学 4 California Institute of Technology 加州理工学院 5 Uni of Oxford 牛津大学 6 Uni of Cambridge 剑桥大学 7 ETH Zurich-Swiss Fedeal Institute of Technology 苏黎世联邦理工大学 8 Imperial College London 帝国理工学院 9 Uni of Chicago 芝加哥大学 10 Uni College London 伦敦大学学院 11 Nathonal Uni of Singapore 新加坡国立大学 12 Nanyang Technological Uni,Singapore 新加坡南洋理工大学 13 Princeton Uni 普林斯顿大学 14 Comell Uni 康奈尔大学 15 Yale Uni 耶鲁大学 16 Columbia Uni 哥伦比亚大学 17 Tsinghua Uni 清华大学 18 The uni of Edinburgh 爱丁堡大学 30 Peking Uni 北京大学 98 Uni of Science and Technology of China 中国科学技术大学"},{"title":"tags","date":"2019-03-22T13:16:06.000Z","updated":"2019-03-22T13:16:35.621Z","comments":true,"path":"tags/index.html","permalink":"http://zehai.info/tags/index.html","excerpt":"","text":""},{"title":"SpringBoot","date":"2019-12-12T02:31:48.000Z","updated":"2019-12-14T07:37:24.564Z","comments":true,"path":"SpringBoot/index.html","permalink":"http://zehai.info/SpringBoot/index.html","excerpt":"","text":"[TOC] Getting Start1.介绍（我们牛逼，开箱即用） 2.开始1.spring-boot精髓之处就是简化了spring的配置， Spring Boot依赖项使用org.springframework.boot，继承自spring-boot-starter-parent，另外还支持gradle(待补充)，下面示例中的注解可以详细看一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Override inherited settings --&gt; &lt;description/&gt; &lt;developers&gt; &lt;developer/&gt; &lt;/developers&gt; &lt;licenses&gt; &lt;license/&gt; &lt;/licenses&gt; &lt;scm&gt; &lt;url/&gt; &lt;/scm&gt; &lt;url/&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.groupId和artifactId（待补充） 3. @RestController来标记控制器（Controller）一个是注释的作用，一个是告诉编译器，处理web请求的时候考虑一下我。 @RequestMapping做路由映射⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄，并返回string类型。 @EnableAutoConfiguration二级注解，这个注释告诉Spring Boot根据所添加的jar依赖关系“猜测”您如何配置Spring。由于spring-boot-starter-web添加了Tomcat和Spring MVC，因此自动配置假定您正在开发Web应用程序并相应地设置Spring。 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) &#123; SpringApplication.run(Example.class, args); &#125;&#125; 4.Main方法 这是遵循Java约定的应用程序入口点的标准方法。我们的主要方法通过调用run来启动Spring Boot的SpringApplication类。SpringApplication会引导我们的应用程序，并启动Spring，并且又会启动自动配置的Tomcat Web服务器。将Example.class作为参数传递给run方法，以告诉SpringApplication哪个是主要的Spring组件。args数组也通过传递以公开任何命令行参数。 5.创建可执行的jar(把程序打包成jar) 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 开始打包：mvn package 看细节：jar tvf target/myproject-0.0.1-SNAPSHOT.jar 原始jar：myproject-0.0.1-SNAPSHOT.jar.origin 6.启动 我将提供一个我在debug的项目供大家调试，https://github.com/ShawnGoethe/money Application.java配置成启动项，在IDEA中就可以启动了，在/hello目录下就可以看到返回的字符串了 3.使用3.1build 依赖管理：会自动升级除非指定依赖包本 maven：继承自spring-boot-starter-parent获得默认配置 序号 特性 1. Java 1.8为基础 2 UTF-8编码方式 3. 继承自spring-boot-dependencies 的A Dependency Management section可以省去version标签 4 An execution of the repackage goal with a repackage execution id. Sensible resource filtering. 5 智能插件配置 6 资源过滤 maven配置你的项目，从继承spring-boot-starter-parent开始 1234567891011&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;!--需要指定版本号，除了导入其他启动器--&gt;&lt;properties&gt; &lt;!--覆盖parent中spring data的配置--&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 如果你不想继承parent配置呢，也可以使用公司的依赖，通过scope标签来保留依赖项目管理↓1234567891011121314151617181920212223242526272829303132&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!--or--&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; maven plugin目的：把你的项目打包成可执行的jar，类似npm里面的包 实现方式：pom中添加：（以下情况为默认配置） 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; gradle（待补充） ant（待补充） starter(命名规则：spring-boot-starter-*) 名称 描述 spring-boot-starter 启动核心（包括自动配置，日志和YAML） spring-boot-starter-activemq Apache ActiveMQ spring-boot-starter-amqp Spring AMQP and Rabbit MQ spring-boot-starter-aop 使用AOP和AspectJ面向切片编程 spring-boot-starter-artemis Apache Artemis spring-boot-starter-batch 使用Spring Batch批处理 spring-boot-starter-cache Spring Framework’s caching spring-boot-starter-cloud-connectors spring-boot-starter-data-cassandra spring-boot-starter-data-cassandra-reactive spring-boot-starter-data-couchbase spring-boot-starter-data-couchbase-reactive spring-boot-starter-data-elasticsearch spring-boot-starter-data-jdbc Spring Data JDBC spring-boot-starter-data-jpa spring-boot-starter-data-ldap spring-boot-starter-data-mongodb spring-boot-starter-data-mongodb-reactive spring-boot-starter-data-neo4j spring-boot-starter-data-redis spring-boot-starter-data-redis-reactive spring-boot-starter-data-rest spring-boot-starter-data-solr spring-boot-starter-freemarker spring-boot-starter-groovy-templates spring-boot-starter-hateoas spring-boot-starter-integration spring-boot-starter-jdbc spring-boot-starter-jersey spring-boot-starter-jooq spring-boot-starter-json spring-boot-starter-jta-atomikos spring-boot-starter-jta-bitronix spring-boot-starter-mail spring-boot-starter-mustache spring-boot-starter-oauth2-client spring-boot-starter-oauth2-resource-server spring-boot-starter-quartz spring-boot-starter-rsocket spring-boot-starter-security spring-boot-starter-test spring-boot-starter-thymeleaf spring-boot-starter-validation spring-boot-starter-web WEB服务包括RESTful，spring MVC应用，继承tomct的容器 spring-boot-starter-web-services spring-boot-starter-webflux spring-boot-starter-websocket 除了上面的应用级别依赖，还有生产环境stater↓ 名称 描述 spring-boot-starter-actuator 帮助监控和管理生产应用程序 如果你想换一些技术可以参考↓ 名称 描述 spring-boot-starter-jetty spring-boot-starter-log4j2 spring-boot-starter-logging spring-boot-starter-reactor-netty spring-boot-starter-tomcat spring-boot-starter-undertow 3.2 结构化代码spring boot：我们很牛逼，不需要任何特定的代码布局就可以开始，但有些结构化可以对编程有帮助 3.2.1使用默认包当类不包含package声明的时候，将视该类在默认程序包中（虽然我们不推荐，它会导致@ComponentScan，@ConfigurationPropertiesScan，@EntityScan，@SpringBootApplication等一些问题） 3.2.2 main类我们建议将main文件放在应用的根目录，@SpringBootApplication的注解会在你的main类上方，它也会隐式定义一些搜索的基础功能，如写JPA的时候，@SpringBootApplication会帮你寻找@Entity注解，文件放在根目录，可以查到所有目录下的@Entity。 3.2.3 常用包tree12345678910111213141516com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java Application.java文件将用@SpringBootApplication注解main主方法12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 3.3 配置类SpringBoot支持基于Java的配置，尽可以使用XML格式的SpringApplication的配置，但我们仍然建议您的主要程序配置是一个简单的配置类，通常，main方法最好使用@Configuration 3.3.1 导入其他配置类不需要把所有配置放在单个配置类中，@Import注解可以帮助你导入其他配置类，另外，你可以使用@ComponentScan来自动获取所有Spring组件，包括@Configuration类 3.3.2 通过xml配置如果你必须使用XML，仍然建议从@Configuration配置类开始，然后你可以使用@ImporResource注解来加载xml配置文件 3.4 自动配置SpringBoot自动配置会尝试根据添加的依赖自动配置Spring应用程序，你需要通过@EnableAutoConfiguration或者@SpringBootApplication（仅能用一个）注解到配置类中 3.4.1逐渐取消自动配置自动配置是不智能的，我们建议您自定义配置来替换自动配置 3.4.2禁用特定的自动配置类通过@EnableAutoConfiguration中的exculde禁用，例如 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration(proxyBeanMethods = false)@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 3.5 Spring beans 和依赖注入(dependencyInjection)你可以任意使用SpringFramework的技术来定义你的bean和注入依赖，如查找bean的@ComponetScan和构造注入的@Autowired 12345678910111213141516171819package com.example.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; //final后续无法修改 private final RiskAssessor riskAssessor; @Autowired //如果bean有了构造器，就不需要@Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 3.6@SpringBootApplication 很受欢迎的一个注解，可以用于启用三个功能 @EnableAutoConfiguration @ComponentScan @Configuration 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 3.7run3.7.1 IDE3.7.2 打包运行3.7.3 使用MavenPlugin3.7.4 使用GradlePlugin3.7.5热更新3.8 开发工具1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.9 打包"},{"title":"Network","date":"2019-03-14T09:20:18.000Z","updated":"2019-04-06T02:58:32.147Z","comments":true,"path":"cnetwork/index.html","permalink":"http://zehai.info/cnetwork/index.html","excerpt":"","text":"基础概念 速率（比特率）：在数字信道传送数据位数的速率,b/s,kb/s,Mb/s(mbps:Mb per second)（运营商常用，进制10进制），也可以理解为带宽的概念 存储容量，1Byte=8bit（进制1024） 时延：发送时延+传播时延+排队时延+处理时延 RTT：往返时延，发送开始到发送方收到接收方的ack，即2*传输时延，不含发送时延，处理时延等 信源：产生和发送数据的源头 信宿：接收数据的终点 信道：信号的传输媒介 单工同行：电报，一方只能发送，一方只能接受 半双工通信：对讲机，双方错开说话 全双工通信：视频电话，双方同时说 OSI 七层模型，TCPIP四层why解决互联网异构问题 what 序号 名称 TCP/IP 常见协议 作用 7 应用层 6 表示层 5 会话层 应用层 4 传输层 传输层 3 网络层 网际层 2 数据链路层 网络接口层 1 物理层 difference index OSI TCPIP 1 理论模型 实际应用 2-网络层区别 无连接+面向连接 无连接 3- 传输层区别 面向连接 无连接+面向连接 面向连接：TCP的建立连接，然后收发数据，断开连接 无连接：无需建立连接，直接发数据 五层参考模型就是将TCP/IP的网络接口层分成了：数据链路层和物理层，从底向上依次是：物理层，数据链路层，网络层，传输层，应用层 传输介质what传输介质是第0层，是物理层下面的载体 分类导向性传输介质：固体，如光纤，双绞线，同轴电缆（电视线） 非导向类传输介质：空气，真空，海水，等 物理层why解决计算机的传输媒体多样性的问题 what主机发送数据无需关心底层的介质是双绞线还是光纤，或者是华为家生产的，还是中兴家生产的。 类比就是你要发一个包裹，你可以选择四通一达以及顺丰，也不用管包裹走水陆空那一路，你只要负责发包裹，剩下的事情，物理层解决 概念 码元：固定时长的信号波形（数字脉冲），举个例子：二进制码元，0和1，四进制码元，00,01,10,11，八进制码元000,001,010,100,011,110,101,111，即，一个码元可以携带多个比特信息 码元传输速率：1s传输多少个码元，单位：波特（Baud） 信息传输速率：码元传输速率*n（1个码元有n个比特表示，如101，n=3）,值就是带宽b/s 编码 解码 编码 名称 特点 二进制数据 非归零编码（NRZ） 简单，但无法检错，无法保持同步 归零编码（RZ） 一个码元内要恢复到零 曼彻斯特编码 下跳是1，上跳是0 差分曼彻斯特编码 同1异0 其他了解：反向不归零编码（NRZI），4B/5B编码 奈氏准则（奈奎斯特定理，传输极限，避免码间串扰）definition在理想环境下，为了避免码间串扰，极限码元传输速率为2W Baud，W为信道带宽，单位Hz 极限数据传输率 $$v=2W\\log_2 V(b.s)$$ W:带宽（Hz） V:几种码元/码元的离散电平数目 意义 码元传输速率有上限 带宽越宽，极限传输率越高 使用多元制的调制方法，提高码元携带的比特数 香农定理（信噪比）definition $$信噪比= \\frac{信号的平均功率}{噪声的平均功率}$$ 记作：S/N$$信噪比（dB）=10\\ln (S/N)$$单位：dB，分贝 以上是信噪比的两种表现形式 香农定理：解决了带宽受限有噪音的信道中，不产生误差，信息的数据传输率的上限（奈斯是理想环境） 传输速率 $$v=W\\log_2 (1+S/N)$$ 单位：b/s W：带宽Hz 题目如果说信噪比是1000，即S/N=1000带入，如果题目说信噪比30dB则带入公式求出S/N的值，再代入公式 意义 信噪比越大，极限传输速率越高 考题注意：题目可能让你求奈氏准则和香农定理的速率，取其最小值为极限速率设备（处理信号） 中继器：再生和还原数字信号 集线器：多口的中继器，放大转发，不能分割冲突域，平分带宽 数据链路层definition数据链路层将网络层的数据可靠的传输到相邻接点的目标及网络层 作用：加强物理层传输原始比特流的功能，将物理层提供的可能出错的连接改为在逻辑上无差错的数据链路 简单来说：数据链路层给报文编号，可以进行流量控制，丢失重发等 作用 提供：无确认无连接，有确认无连接，有确认面向连接服务 链路管理，连接的建立、维持、释放 组帧 流量控制 差错控制 组帧在网络层的数据头尾添加：帧首部，帧尾部，让对方说识别帧的开始和结束 组帧的四种方法：（Transmission） 字符计数法：帧首部第一字节记录帧的长度（传输过程中，这个字符可能被修改，或者丢失，后续帧全部错误） 字符填充法：帧首部填充SOH（00000001）,尾部填充EOT（00000100）（数据部分有可能有SOH,EOT—&gt;解决方式，转义字符） 零比特填充法：比如首部01111110，则数据部分遇到五个1填充一个0，来避免假SOH 违规编码法：如曼彻斯特会有，高-低–&gt;1，低-高–&gt;0,然后用低低和高高来做SOH,EOT 最大传输单元MTUwhy因为一个帧中IP数据包的内容不可能无限大 whatMTU最大传送单元 差错控制差错分为两种： 位错：比特位数字出错 修正位错： 检错编码：奇偶校验，CRC循环冗余码（只知道错了） 纠错编码：海明码（知道错了，还知道错哪儿了） 帧错：丢失，重复，失序 修复帧错： 重传 冗余编码：数据放松之前，附加冗余位，使之符合某种规则，接收端检查不符合规则就判断为出错（即，奇偶校验，CRC，海明码） 奇偶校验码（n-1位信息元，1位校验元） 奇校验码：1的个数为奇数 偶校验码：1的个数为偶数 例：1100101奇校验–&gt;11100101 “1”可以填到任意位置，只要有奇数个“1”，接收方就认为这一段没有出错，但如果丢了两个“1”就检查不错来了，所以出现了CRC CRC循环冗余要传的数据/多项式=商……余数 发送的数据=要传的数据+余数（FCS帧检验序列，又称冗余码） 例题：1101011011 生成多项式10011 要传的数据末尾加上4个0，除以10011余数1110，则发送的数据为：1101011011 1110 检查：11010110111110%10011==0则帧没有出错，否则丢弃 FCS的生成及校验是硬件实现，处理迅速，不会延迟 海明码1.发现双比特错，纠正但比特错 2.工作原理：牵一发而动全身 3.确定校验码位数r–&gt;确定校验码和数据的位置–&gt;求出校验码的值–&gt;检错并纠错 1.去顶校验码位数r海明不等式：2^r≥k+r+1(r为冗余信息位，k为信息位) 例如：要发送的数据D=101101 数据位数k=6,满足不等式的最小r为4，也就是海明码有6+4=10位，即数据位6位，校验4位 2.确定校验码和数据的位置校验码放在2的几次方的位置，剩下填数据位就可以了 3.求校验码的值第一位校验码校验二进制最后一位为1的数 第二位校验码校验二进制倒数第二位为1的数字 以此类推 令校验位与选中的数异或为0，就可以得到校验位的值 得到101101的海明码是：0010011101（第1,2,4,8为为校验位） 4.检错并纠正取校验位做异或运算，得到的值就是出错的位置（上述例子中假设第五位出错，则四个校验码的值，拼起来的和就是5 流量控制和可靠传输机制what解决发送和接受能力不匹配的问题 difference 数据链路层 传输层 流量控制 点到点（相邻节点） 端到端 手段 收不下，不返回确认帧 接收端发送窗口公告 流量控制方法 停止-等待协议 滑动窗口协议： 回退N帧协议（GBN：go back N） 选择重传协议SR 停止-等待协议（等确认帧再发送）没发送完一个帧就停止发送，等待对方的确认，在收到确认后在发送下一个帧 丢帧重传时间(数据丢之或者ack丢失)：&gt;RTT 数据丢失重传 ack丢失，数据重传，接收方丢弃，重传ACK ack迟到，数据重传，接收方丢弃，重传ACK，收到第二次发的确认帧，后续收到迟到的ack丢掉 流水线技术：一次发送多帧（滑动窗口的起源） 滑动窗口协议（窗口多帧发送）采用累积确认 停止等待 GBN SR 发送窗口 1 &gt;1 &gt;1 接受窗口 1 1 &gt;1 GBN特点 上层调用（发送或缓存网络层数据） 累计确认（ack为最后收到的帧的编号） 超时重传 （缺点，选择重传修正这个问题）接收方无缓存，延迟或者出错全部丢弃（如果1号收到2号丢失，3,4号陆续到了都丢弃，等待发送发超时重传2号帧） GBN滑动窗口的长度：$$1≤W≤2^n-1$$因为发送窗口过大，会使得对方区别新帧和旧帧，即编号的数目可能是固定的，他是循环利用的，可能会重复 选择重传协议（SR=GBK+接收方有窗口）：缓存收到的帧，返回确认收到帧的编号（不代表编号前的帧都收到），窗口长度：$$1≤W≤2^n-1$$发送方窗口=接收方窗口（大了溢出，小了没意义） 信道利用率发送周期内，有效发送数据所占据的比例，也就是（发送数据帧时间）除以（发送数据帧开始到接收到ack的总时间）$$信道利用率=（L/C）/T$$L:T内发送L比特数据 C：发送方数据传输率 T:发送周期，发送到收到ack 信道吞吐率信道利用率* 发送方的发送速率 数据传输速率4kb/s，单向传播时延30ms，如果停止等待协议的信道最大利用率达到80%，数据帧长度为？ $$0.8=\\frac{L/4}{L/4+2*30}$$ 信道划分介质访问(高效率利用传输介质)分两种 点对点链路：专有线路，如ppp协议 广播式链路：共享通信介质，如对讲机 介质访问控制 静态分配（不冲突） 频分复用FDM(Frequency Division Multiplexing) 时分复用TDM(time) 波分复用WDM（wave） 码分复用CDM（code） 动态分配 轮训访问： 令牌（不冲突） 随机访问：（冲突） aloha CSMA CSMA/CD CSMA/CA 1.统计时分复用STDM 提出原因：有的主机在这个时间片不会发送信息，信道造成浪费 通过集中器，ABCD四个人，集中器大小设定为3，每来3个人，就发送走一波数据 解决TDM平分带宽的问题，集中器的TDM帧可以发送的数据都是一个人的数据，从而不影响带宽 2.CDMA码分多址，是CDM的一种方式 CDM（后续补充，没听懂）1个比特分为多个chip（芯片/码片），每个站点被指定一个唯一的m位的chip序列 如何划分信道？ 多个站点同时发送数据时候，要求各个站点芯片序列相互正交 多个站点接收数据的时候，数据在信道中被线性相加 ALOHA协议（想发就发）特点：不监听信道，不按时间片发送，随机重发（发的时候彼此不知道冲突，所以可能两个人都发送失败） ALOHA改进：时隙ALOHA协议，将时间分片，用户在时间片开始时刻同步接入网络信道，如果冲突，则下个时间片开始时刻再发送 CSMA协议家族（先听再发） CSMA:carrier sense multiple access CS:载波侦听：发送前检测 MA：多点接入 信道忙 1-坚持CSMA：一直监听到信道闲，冲突则等待随机时间再来一直监听 信道利用率高 两个站点都坚持，死锁 非坚持CSMA：等待随机时间后再监听 减少冲突可能性 信道利用率低 p-坚持CSMA：空闲以p概率传输，忙则以概率1-p等待下个时间片（不必深究），忙则等待随机时间再监听 减少冲突 信道利用率较高 发生冲突后可能会坚持把数据帧发完（提出CD协议） CDMA/CD（先听再说：边听边说） cd:collision detection碰撞检测 在CSMA基础上，发送数据时也监听信道，忙则停止发送–半双工网络 争用期/冲突窗口/碰撞窗口：2T，如果没有碰撞则这次发送不会有冲突 如何确定重传？截断二进制指数规避算法（待完善） 最小帧长（避免还没碰撞检测完，数据已经发送结束了）：帧长&gt;=2T*数据发送速率 以太网规定最短帧长64B，凡是小的都是无效帧，丢弃 CDMA/CA（先听再说，礼让说） CA：collision acoidance避免碰撞 应用于无线局域网的冲突 先检测信道是否空闲–&gt; 空闲时发送RTS（request to send：发送端地址，接收端地址，发送持续时间），忙则等待–&gt; 接收端收到RTS，响应CTS（clear to send），再次期间不会再响应别人的RTS–&gt; 发送方收到CTS后，开始发送数据帧（同时预约信道：发送方告知预计传输时间,从而告知别的站点多久后重发）–&gt; 接收端收到数据帧，采用CRC来检验数据，正确则响应ACK，如果丢失遵循上面的规避算法来确定推迟重发时间 CSMA/CD CSMA/CA 传输介质 有线 无线 载波检测方式 电压 能量检测，载波检测，能量波混合检测 冲突类型 检测冲突 避免冲突 相同点：先听再说，监听，冲突后，有限次重传机制 轮询访问介质访问控制轮询协议：主节点轮流和从属节点发送数据 轮询开销大 等待延迟 主节点故障 令牌传递协议： 令牌：一个特殊格式的MAC控制帧，不含任何信息 每个节点可以拿到令牌一段时间，发送数据 令牌开销大 等待延迟 单点故障 应用于环网 适用于负载重，通信量大的网络中 局域网（Local Area Network） 范围小 速度较快 延迟短，误码率低，可靠性高 共享 分布式控制，广播式通信，能广播和组播 星型拓扑，总线型拓扑（CSMA/CD，令牌总线产生逻辑环），环形拓扑（令牌环），属性拓扑 局域网分类：以太网，令牌环网，FDDI网,ATM网，无线局域网 数据链路层=逻辑链路层LLC+截止访问控制MAC层 LLC识别网络层协议并封装，知道如何处理ACK，为网络层提供：无确认无连接，面向连接，带确认连接，高速传送 MAC，帧的封装，拆封，帧的寻址识别，发送接收，链路管理，帧差错控制，屏蔽物理链路种类的差异性 以太网（Ethernet） 便宜 使用广泛 相对简单 速率较高 提供无连接，不可靠的服务： 无连接：无需握手 不可靠，没有编号，不确认，差错丢弃（传输层负责） 通过通信适配器通信：MAC地址，前24位代表厂家，后24位自己规定，常用6个十六进制数字表示 无线局域网广域网PPP协议：点对点协议，只支持全双工 简单：无需纠错，无需编号，无需流量控制 封装成帧：帧定界符 透明传输：异步线路字节填充，同步线路比特填充 多种网络层协议：封装IP数据包采用多种协议 多种类型链路：串并行，同异步，光电…… 差错检测：错丢弃 检测连接状态 最大传送单元：数据部分最大MTU 网络层地址协商 数据压缩协商 PPP组成的三个部分： 一个将IP数据包封装到串行链路（同异步串行）的方法 链路控制协议LCP：建立和维护数据链路连接 网络控制协议NCP：PPP支持多种网络层协议，对应NCP来配置，为网络层建立和配置逻辑连接 PPP帧格式 HDLC协议 高级数据链路控制：High-level data link control，是一个同步网上传输数据，面向比特的数据链路层协议 三种站： 主站 从站 复合站 PPP&amp;HDLC共同点 全双工 透明传输 查错但不纠错 不同点： 不同点 PPP HDLC 面向 字节 比特 协议字段 有 没有 序号和ACK 无 有↓ 可靠性 不可靠 可靠 链路层设备 网桥：根据MAC的目的地址进行帧的转发和过滤（隔离冲突域） 过滤通信量，增大吞吐量 扩大物理范围 提高可靠性 互联不同物理层 交换机 网桥 透明网桥：以太网上的站点不知道所发送的帧经过了哪几个网桥，是一种热插拔设备–自学习（通过广播来学习转发表） 源路由网桥：把详细的最佳路由信息（路由最少\\时间最短）放在帧的首部——通过广播方式向目的站发送一个发送帧 以太网交换机（多接口网桥） 直通式：检查地址直接转发（延迟小，可靠性低，无法支持不同速率的端口交换） 存储转发式：将帧放入高速缓存，检查正确性，正确则转发，错误丢弃（延迟大，可靠性高，支持不同速率端口） 隔离冲突域 隔离广播域 物理层（中继器，集线器） × × 链路层（网桥，交换机） √ × 网络层（路由） √ √ 诀窍 广播域，0个路由1个广播域，1个路由2两个广播域 冲突域：链路层设备（交换机）有几根线就是几个冲突域 网络层功能把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 路由选择和分组转发（最佳路径OSPF） 异构网互联 控制拥塞 开环控制（静） 闭环控制（动态控制） 数据交换方式 电路交换（两端一根线直连） 报文交换 分组交换 有两种连接方式 数据报方式：无连接服务（无需建立连接，每个分组都有地址） 虚电路方式：连接服务（建立连接） 数据报服务 虚电路 建立连接 × √ 目的地址 每个分组都有 建立有，分组只有虚电路号 路由选择 每个分组独立进行路由选择转发 同一路径 分组顺序 不保证有序 有序 可靠性 不可靠通信，可靠性由主机保证 可靠性由网络保证 网络故障适应性 遇故障丢失，其他分组路径发生变化 所有经过此节点都丢包 差错处理和流量控制主机 控制，本身不保证 分组交换网负责或者主机负责 报文的分装应用层：报文 传输层：报文段 网络层：IP数据包，分组 数据链路层：帧 物理层：比特流 IP ip数据报格式ip数据报=首部+数据部分 ip 数据报分片MTU以太网最大MTU是1500字节 IP数据报第32-63位，标识（16）+标志（3）+片偏移（13） 标识（16）：统一数据报的分片使用同一标识 标志（4）：中间位DF，DF=1禁止分片，DF=0允许分片，最低位MF,MF=1后面还有分片，MF=0,后面没有分片了 片偏移：分片后相对位置，除了最后一个分片，其他都是8B的整倍数 总长度：单位1B 片偏移：单位是8B 首部长度：单位是4B NATip地址转化表，通过端口来实现地址映射 IP分类子网掩码无分类编址CIDR ARP（IP-MAC）广播ARP请求分组 源ip+目的ip+源MAC+目的MAC(全1) 单播ARP响应分组 ip+mac 如果A–&gt;B经历5个路由，一共要使用6次ARP协议 DHCP（应用层协议，广播，基于UDP，CS架构）静态配置ip 动态配置ip–&gt;DHCP协议 主机广播DHCP发现 DHCP服务器广播DHCP提供 主机广播DHCP请求 DHCP服务器广播DHCP确认 ICMPICMP支持主机或者路由器 差错报告 网络探寻 ICMP报错 含义 终点不可达 无法交付 源点抑制（已取消） 目标向源主机发送，发慢点 时间超过 TTL=0时，发送超时报文 参数错误 首部字段有问题 重定向 让主机重新选择路由 ICMP差错报告报文数据字段 不发送ICMP差错报文的情况 对本身的报错出错不再报错 第一分片报错，后去分片不报错 组播不报错 特殊地址不报错（0.0.0.0/127.0.0.1） ICMP询问报文： 回送请求和回答报文（ping） 时间戳请求和回答报文（时间同步和测量时间） ICMP应用 PING Traceroute：跟踪分组发送的路径，使用ICMP时间超过差错报文 IPv4(32bit) 不能使用的ip地址 网络号 主机号 作ip源地址 作IP目的地址 用途 全0 全0 √ × 默认路由 全0 特定值 × √ 表示本网内某个特定的主机 全1 全1 x √ 广播地址 特定值 全0 x x 网络地址，表示一个网络 特定值 全1 x √ 直接广播地址，对特定网络上的所有主机广播 127 除全0,1 √ √ 用于本地软件换回测试 另一种 地址范围 网段数 A类 10.0.0.0~10.255.255.255 1 B 172.16.0.0~172.31.255.255 16 C 192.168.0.0~192.168.255.255 256 ABC为专属内部网络地址 IPv6（128bit）首部40bit+有效负荷（≥64k） 网络层设备路由 静态路由算法 动态路由算法 全局性：链路状态路由算法OSPF（规模大） 分散性：距离向量路由算法RIP（规模小） 自制系统AS：在单一技术管理下的一组路由器（一个局域网内，自己管理自己的，要不然路由算法无法完成） 路由选择协议 内部网关协议IGP（AS内）RIP,OSPF 外部网关协议EGP（AS间）BGP RIP定义：一种分布式基于距离向量的路由选择协议，简单，维护自己到目的网络唯一最佳距离（跳数）记录 feature： 仅相邻交换信息 每30s更新路由表，180s无消息则判断邻居没了 故障发现慢（你发现旁边故障了，但邻居以为经过你就可以到达，然后你以为经过邻居，再经过你就可以到达，循环到，双方都变成16跳，才发现网络故障） OSPF（类似Dijkstra）分布式链路状态feature： 自治系统内广播（非RIP的相邻） 交换链路状态（费用，距离，时延，带宽等） 链路状态变化才更新 每隔30分钟刷新一次数据库中的链路状态 故障发现比较快 OSPF分区： BGPAS间通信，交换网络可达性信息，发生变化时更新 OPEN–&gt;UPDATE–&gt;KEEPALIVE–&gt;NOTIFICATION 协议 RIP OSPF BGP 类型 内部 内部 外部 路由算法 距离-向量 链路状态 路径-向量 传递协议 udp ip TCP 路径选择 跳数最少 代价最低 较好，非最佳 交换节点 相邻 所有 相邻 交换内容 自身路由表 所有 首次整个路由表，非首次，变化内容 IP组播（D类地址） 单播 广播 组播（多播）基于UDP IGMP协议+组播路由选择协议 传输层 进程间逻辑通信 复用和分用 差错检测 TCP UDP 端口号（16bit） 服务端0-1023 服务端1024-49151 客户端49152-65535 service port FTP 21 TELNET 23 SMTP 25 DNS 53 TFTP 69 HTTP 80 SNMP 161 Socket=ip+port UDPFEATURE: 无连接 不保证可靠交付 面向报文 无拥塞控制 首部开销小8B，小于20B（TCP） UDP检验 TCPFEATURE 面向连接 点对点 可靠有序 全双工 面向字节流 序号 确认号：期望收到的序号 数据偏移 URG：紧急位，值为1时高优先级发送 ACK：确认位，连接建立后等于1 PSH:推送位，值为1时，接收方尽快交付给应用进程 RST：复位，必须释放连接 SYN：同步位，1，标明是一个连接请求/连接接受报文 FIN：释放连接 窗口：接受窗口，即允许发送方的数据量 校验和 紧急指针：指出URG=1时，紧急数据的字节数 三次握手 四次挥手 流量控制窗口控制待补充"}],"posts":[{"title":"2020-03-06-BinaryTreeInorderTraversal","slug":"2020-03-06-BinaryTreeInorderTraversal","date":"2020-03-06T03:55:16.000Z","updated":"2020-03-06T09:46:43.499Z","comments":true,"path":"2020/03/06/2020-03-06-BinaryTreeInorderTraversal/","link":"","permalink":"http://zehai.info/2020/03/06/2020-03-06-BinaryTreeInorderTraversal/","excerpt":"","text":"Problem94Given a binary tree, return the inorder traversal of its nodes’ values. 给定一二叉树，中序遍历输出 ps:preorder,inorder,postorder，前中后 Keyrecursive approach利用递归解决B树的遍历问题，这种问题的代码其实大同小异，前中后的遍历输出，只需要调整递归部分即可 123456789101112131415161718192021222324252627//preorderpublic void preorder(node t) if (t != null) &#123; System.out.print(t.value + \" \"); preorder(t.left); preorder(t.right); &#125;&#125;//inorderpublic void inorder(node t)&#123; if (t != null) &#123; inorder(t.left); System.out.print(t.value + \" \"); inorder(t.right); &#125;&#125;//postorderpublic void postorder(node t)&#123; if (t != null) &#123; postorder(t.left); postorder(t.right); System.out.print(t.value + \" \"); &#125;&#125;//leverorder Solution Runtime: 0 ms, faster than 100.00% of Java online submissions for Binary Tree Inorder Traversal. Memory Usage: 37.9 MB, less than 5.11% of Java online submissions for Binary Tree Inorder Traversal. 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List &lt; Integer &gt; res = new ArrayList &lt; &gt; (); inorder(root, res); return res; &#125; public void inorder(TreeNode root, List &lt; Integer &gt; res) &#123; if (root != null) &#123; inorder(root.left, res); res.add(root.val); inorder(root.right, res); &#125; &#125;&#125; Complexity Analysis Time complexity : O(n)O(n). The time complexity is O(n)O(n) because the recursive function is T(n) = 2 \\cdot T(n/2)+1T(n)=2⋅T(n/2)+1. Space complexity : The worst case space required is O(n)O(n), and in the average case it’s O(\\log n)O(logn) where nn is number of nodes. stacksolution还提供了另外一种方法通过stack pop的方式来完成： https://leetcode.com/problems/binary-tree-inorder-traversal/solution/ Morris同上","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"2020-03-05-hexoNexTv7.7.2","slug":"2020-03-05-hexoNexTv7-7-2","date":"2020-03-05T06:42:08.000Z","updated":"2020-03-06T10:24:52.371Z","comments":true,"path":"2020/03/05/2020-03-05-hexoNexTv7-7-2/","link":"","permalink":"http://zehai.info/2020/03/05/2020-03-05-hexoNexTv7-7-2/","excerpt":"","text":"I find hexo’s theme:nexT v7.7.2 has some new features native dark modewe can set 1darkmode:true to open native dark mode and there are other features like support MathJax v3.0,we use $$ add next_config helper how to update newest version1.git clone https://github.com/theme-next/hexo-theme-next themes/next or in releases to download newest source code 2.copy file to hexo/theme/ such as : /themes/hexo-theme-next-7.7.2/ 3.open hexo’s _config.yml,and change theme’s value to hexo-theme-next-7.7.2 and u change your them successfully 4.update /themes/hexo-theme-next-7.7.2/_config.yml Last , u can create new post to log your daily life 1yarn upgrade caniuse-lite browserslist and these days ,zehai.info ,may Expired ,sad","categories":[{"name":"others","slug":"others","permalink":"http://zehai.info/categories/others/"}],"tags":[{"name":"NexT","slug":"NexT","permalink":"http://zehai.info/tags/NexT/"}]},{"title":"2020-02-28-JS相关技术名词","slug":"2020-02-28-JS相关技术名词","date":"2020-02-28T12:07:43.000Z","updated":"2020-03-06T09:58:09.823Z","comments":true,"path":"2020/02/28/2020-02-28-JS相关技术名词/","link":"","permalink":"http://zehai.info/2020/02/28/2020-02-28-JS相关技术名词/","excerpt":"","text":"今天中午有收到Egg团队公开的文件调查，提及了很多技术名词，虽然不一定用到，但我也觉得列举出来会方便大家了解和比较，后续可能更新我用过的部分 代码检查工具 ESLint JSCS JSHint JSDoc Standard TSLint Flow 引入目的：规范代码 ESLint 通过extend继承某一个大类，然后配置rules来进行代码规范 JSCS JSHint JSDoc Standard TSLint Flow 使用感受解决了以下问题 node是一门弱语言，进行校验（非变量类型校验，仅校验变量是否声明，是否可改等） node在use strict模式下，eslint可以校验 团队合作，防止队友挖坑 其实ESLint只是一种语法校验，更多的还有流程上的规范，就像网传阿里的开发规范一样，就好比node中你可以用类的语法糖，也可以用原型，当一件事情有多种实现方式时，需要规范来选择一个普遍公用的，易维护，易扩展的方案 除去语法校验，还有TS的类型校验，比如GIT的分支规范，如master,staging,backup,develop,other branch 转义语言 [ x ] TS ClojureScript CoffeeScript Dart Elm Scala.js Haxe Nim PureScript Reason 转移语言是2019年聊的比较多的，解决问题： 类型校验，能够很好解决JS开发中，你不知道这个object里面有什么key，或者某个对象里面有什么方法（egg.js实际开发过程中，ctx.service.v1.handlexxx()就ctrl跳转不了，也不会有提示） WEB框架 Express Koa Egg Nest.js Next.js Fastify.js Hapi.js Restify.js Loopback.io Sails.js Midway.js 面试常被问到框架的问题，因为很多公司不会将项目搭建在原生的node服务上 缺少约束，合作模式下，个人有个人的风格 项目配置繁琐，很多东西配置零散堆放 重复造轮子，框架提供较好的轮子 安全事宜，框架处理 etc 一个好的框架事半功倍，express是一个非常轻量的框架 fast unopinionated(干净的) minimalist Egg是一个企业级框架，约定大于配置 Provide capability to customizd framework base on Egg（可扩展） Highly extensible plugin mechanism（插件牛逼） Built-in cluster（多进程牛逼） Based on Koa with high performance（企业级别性能优异） Stable core framework with high test coverage（稳定） Progressive development（业务迭代，代码可以渐进继承） 数据库 MySQL PostgreSql Redis MongoDB SQL Server SQLLite influxdb HBASE TiDB Oracle DB2 数据库是仅此于语言本身，另外的考点了，因为没有一个服务不涉猎存储，而 反向代理 Nginx Tomcat Apache 进程管理 Docker PM2 forever naught node-supervisor Supervisord(Unix) RPC方式 HTTP Thrift gRPC dubbo MQ 开发场景 服务端API SSR应用 Proxy层 BFF层 代码片段，如Spark代码片段 CLI &amp; 工具 tips","categories":[],"tags":[{"name":"List","slug":"List","permalink":"http://zehai.info/tags/List/"}]},{"title":"2020-01-31-JS设计模式","slug":"2020-01-31-JS设计模式","date":"2020-01-31T08:39:11.000Z","updated":"2020-01-31T08:50:38.390Z","comments":true,"path":"2020/01/31/2020-01-31-JS设计模式/","link":"","permalink":"http://zehai.info/2020/01/31/2020-01-31-JS设计模式/","excerpt":"","text":"模式共计八种： 单例模式 构造器模式 建造者模式 代理模式 外观模式 观察者模式 策略模式 迭代器模式 设计模式的提出，为了更好的解耦，可拓展，服务可靠，不限定某种语言的实现 单例模式概念一个类只有一个实例，如果存在就不实例化，如果不存在则new，以保证一个类只有一个实例 作用 模块间通信 保证某个类的对象的唯一性 防止变量污染 注意 this的使用 闭包容易stack over flow需要及时清理 创建新对象成本较高 实际案例如网站的计数器，多线程的线程池 12345678910111213141516171819202122232425(function()&#123; // 养鱼游戏 let fish = null function catchFish() &#123; // 如果鱼存在,则直接返回 if(fish) &#123; return fish &#125;else &#123; // 如果鱼不存在,则获取鱼再返回 fish = document.querySelector('#cat') return &#123; fish, water: function() &#123; let water = this.fish.getAttribute('weight') this.fish.setAttribute('weight', ++water) &#125; &#125; &#125; &#125; // 每隔3小时喂一次水 setInterval(() =&gt; &#123; catchFish().water() &#125;, 3*60*60*1000)&#125;)() 构造器模式","categories":[],"tags":[]},{"title":"2020-01-31-RomanToInteger","slug":"2020-01-31-RomanToInteger","date":"2020-01-31T03:17:45.000Z","updated":"2020-01-31T04:29:47.236Z","comments":true,"path":"2020/01/31/2020-01-31-RomanToInteger/","link":"","permalink":"http://zehai.info/2020/01/31/2020-01-31-RomanToInteger/","excerpt":"","text":"Leetcode13Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3Example 2: Input: “IV”Output: 4Example 3: Input: “IX”Output: 9Example 4: Input: “LVIII”Output: 58Explanation: L = 50, V= 5, III = 3.Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Solution题目意思其实很简单，掌握了计算方法其实很简单 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int romanToInt(String s) &#123; int nums[]=new int[s.length()]; for(int i=0;i&lt;s.length();i++)&#123; switch (s.charAt(i))&#123; case 'M': nums[i]=1000; break; case 'D': nums[i]=500; break; case 'C': nums[i]=100; break; case 'L': nums[i]=50; break; case 'X' : nums[i]=10; break; case 'V': nums[i]=5; break; case 'I': nums[i]=1; break; &#125; &#125; int sum=0; for(int i=0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;nums[i+1]) sum-=nums[i]; else sum+=nums[i]; &#125; return sum+nums[nums.length-1]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Easy","slug":"Easy","permalink":"http://zehai.info/tags/Easy/"}]},{"title":"2020-01-31-内网穿透","slug":"2020-01-31-内网穿透","date":"2020-01-31T02:16:51.000Z","updated":"2020-01-31T02:41:23.349Z","comments":true,"path":"2020/01/31/2020-01-31-内网穿透/","link":"","permalink":"http://zehai.info/2020/01/31/2020-01-31-内网穿透/","excerpt":"","text":"why解决公网访问自己的内网设备（大部分公司，小区都是在内网中，IPv4历史原因导致），解决方案： 路由器新增端口映射 花生壳动态解析软件 natapp等免费软件提供的内网映射服务 基于ngrok（不荐）或者frp自建内网映射服务 how目前推荐使用frp搭建穿透服务，支持HTTP，SSH,TCP UDP FTP","categories":[],"tags":[]},{"title":"2020-01-18-plugins","slug":"2020-01-18-plugins","date":"2020-01-18T15:58:31.000Z","updated":"2020-01-31T03:53:24.884Z","comments":true,"path":"2020/01/18/2020-01-18-plugins/","link":"","permalink":"http://zehai.info/2020/01/18/2020-01-18-plugins/","excerpt":"","text":"最近更新hexo比较频繁，发现频繁性的推送master分支以及source源文件备份，比较繁琐，查询了官方文档，可以写一些监听函数，实现一些自动化部署，hexo默认将脚本放置在scripts文件夹下，以下代码可以在hexo new的时候自动打开默认编辑软件 12345var spawn = require(&apos;child_process&apos;).exec;hexo.on(&apos;new&apos;, function(data)&#123; spawn(&apos;start &quot;markdown编辑器绝对路径.exe&quot; &apos; + data.path);&#125;); 非常的方便，省去了我打开typora的时间 以及以下的代码可以实现自动部署source分支 1234567891011121314151617181920212223242526272829303132333435require(&apos;shelljs/global&apos;);//记得安装包try &#123; hexo.on(&apos;deployAfter&apos;, function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(&quot;You make a wrong：&quot; + e.toString());&#125;function run() &#123; if (!which(&apos;git&apos;)) &#123; echo(&apos;Sorry, this script requires git&apos;); exit(1); &#125; else &#123; echo(&quot;======================Auto Backup Begin===========================&quot;); cd(&apos;./&apos;); if (exec(&apos;git add --all&apos;).code !== 0) &#123; echo(&apos;Error: Git add failed&apos;); exit(1); &#125; if (exec(&apos;git commit -am &quot;Form auto backup script\\&apos;s commit&quot;&apos;).code !== 0) &#123; echo(&apos;Error: Git commit failed&apos;); exit(1); &#125; if (exec(&apos;git push origin source&apos;).code !== 0) &#123; echo(&apos;Error: Git push failed&apos;); exit(1); &#125; echo(&quot;==================Auto Backup Complete============================&quot;) &#125;&#125; 参考文献https://hexo.io/zh-cn/docs/plugins#%E5%B7%A5%E5%85%B7","categories":[],"tags":[]},{"title":"2020-01-17-ImplementStr","slug":"2020-01-17-ImplementStr","date":"2020-01-17T10:25:30.000Z","updated":"2020-01-17T10:41:37.267Z","comments":true,"path":"2020/01/17/2020-01-17-ImplementStr/","link":"","permalink":"http://zehai.info/2020/01/17/2020-01-17-ImplementStr/","excerpt":"","text":"LeetCode28Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = “hello”, needle = “ll”Output: 2Example 2: Input: haystack = “aaaaa”, needle = “bba”Output: -1Clarification: What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Solution如果不考虑java偷懒的写法当然可以想到indexof的想法123456class Solution &#123; public int strStr(String haystack, String needle) &#123; return haystack.indexOf(needle); &#125;&#125;Runtime: 1 ms 先按照题意写了如下代码：1234567891011121314151617181920212223242526272829class Solution &#123; public int strStr(String haystack, String needle) &#123; if(needle.length()==0)return 0; if(haystack.length()==0)return -1; int index =-1; boolean flag = true; for(int i=0;i&lt;haystack.length();i++)&#123; if(haystack.charAt(i)==needle.charAt(0))&#123; flag=true; for(int j =0;j&lt;needle.length();j++)&#123; if(i+j&gt;=haystack.length())&#123; return -1; &#125; if(haystack.charAt(i+j)!=needle.charAt(j))&#123; flag=false; break; &#125;; &#125; if(flag)&#123; return i; &#125; &#125; &#125; return index; &#125;&#125;Runtime: 4 msMemory Usage: 42.7 MB","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Easy","slug":"Easy","permalink":"http://zehai.info/tags/Easy/"}]},{"title":"2020-01-15-sqrtx","slug":"2020-01-15-sqrtx","date":"2020-01-15T14:04:46.000Z","updated":"2020-01-15T15:02:18.884Z","comments":true,"path":"2020/01/15/2020-01-15-sqrtx/","link":"","permalink":"http://zehai.info/2020/01/15/2020-01-15-sqrtx/","excerpt":"","text":"LeetCode-69Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2Example 2: Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. Solution就是手写一个根号源码，首先想到的就是通过平方来做 12345678910public int mySqrt(int x) &#123; for(int i=46340;i&lt;46341;i++)&#123; if(x&gt;=(long)i*i&amp;&amp;x&lt;(long)(i+1)*(i+1))&#123; return i; &#125; &#125; return x; &#125;Runtime: 22 msMemory Usage: 34 MB 如果不遵循题目的要求，使用Math函数，所以我们的目标大概是3ms附近 1234public int mySqrt(int x) &#123; return (int)Math.sqrt(Double.parseDouble(String.valueOf(x))); &#125;Runtime: 3 ms 解法粗暴，遇到大数的时候会从0重新开始计算，复杂度O(N) 第一次优化思路就是避免做两次乘法然后去比较，这个地方可以去优化 12345678910class Solution &#123; public int mySqrt(int x) &#123; long n = 1; while(n * n &lt;= x) &#123; n++; &#125; return (int) n - 1; &#125;&#125;Runtime: 11 ms 第二次优化可以使用二分法来逐步逼近i，没有必要从1开始顺序遍历 12345678910111213141516171819202122class Solution &#123; public int mySqrt(int x) &#123; if (x == 0 || x == 1) return x; int left = 1; int right = x; while (left &lt; right) &#123; int midPoint = (left + right) / 2; if (midPoint == x / midPoint) &#123; return midPoint; &#125; else if (midPoint &gt; x / midPoint) &#123; right = midPoint; &#125; else if (midPoint &lt; x / midPoint) &#123; left = midPoint + 1; &#125; &#125; return left - 1; &#125;&#125;Runtime: 1 ms","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Easy","slug":"Easy","permalink":"http://zehai.info/tags/Easy/"}]},{"title":"2020-01-11-SameTree","slug":"2020-01-11-SameTree","date":"2020-01-11T07:45:18.000Z","updated":"2020-01-11T07:48:43.532Z","comments":true,"path":"2020/01/11/2020-01-11-SameTree/","link":"","permalink":"http://zehai.info/2020/01/11/2020-01-11-SameTree/","excerpt":"","text":"LeetCode 10012345678910111213141516171819202122232425262728293031Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false Solution题目其实很简单的一个递归Recursion,我们很轻松可以通过递归来解决1234567891011class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; // p and q are both null if (p == null &amp;&amp; q == null) return true; // one of p and q is null if (q == null || p == null) return false; if (p.val != q.val) return false; return isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left); &#125;&#125; 时间复杂度为O(n)，控件复杂度为O(logn)~O(n)之间，这道题就不考虑其他解法了，recursion目前看来是最优解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"2020-01-10-MatrixZero","slug":"2020-01-10-MatrixZero","date":"2020-01-10T15:15:26.000Z","updated":"2020-01-10T15:50:04.238Z","comments":true,"path":"2020/01/10/2020-01-10-MatrixZero/","link":"","permalink":"http://zehai.info/2020/01/10/2020-01-10-MatrixZero/","excerpt":"","text":"LeetCode 731234567891011121314151617181920212223242526272829303132333435Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.Example 1:Input: [ [1,1,1], [1,0,1], [1,1,1]]Output: [ [1,0,1], [0,0,0], [1,0,1]]Example 2:Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]]Follow up:A straight forward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution? Solution一开始以为递归可以解决，可以将矩阵一层层拆开，写下了如下的代码：123456789101112131415161718192021222324252627282930313233343536373839public void setZeroes(int[][] matrix) &#123; int rows = matrix.length-1; int cols = matrix[0].length-1; regression(matrix, rows&gt;=cols?cols:rows);&#125;public void regression(int[][] matrix,int index)&#123; if(index&lt;0)&#123; return; &#125; boolean flag = false; for(int i =index;i&lt;matrix[0].length;i++)&#123; if(matrix[index][i]==0) &#123; handleZero(matrix,i); flag=true; break; &#125; &#125; if(flag==false)&#123; for(int j =index;j&lt;matrix.length;j++)&#123; if(matrix[j][index]==0) &#123; handleZero(matrix,j); break; &#125; &#125; &#125; regression(matrix, --index);&#125;private void handleZero(int[][] matrix,int pos) &#123; for(int i=matrix[0].length-1;i&gt;=pos;i--)&#123; matrix[pos][i]=0; &#125; for(int j=matrix.length-1;j&gt;=pos;j--)&#123; matrix[j][pos]=0; &#125;&#125; 写完后很快发现不能够实现，原因就在于他只能管理到内层，外层标为0后，没办法做额外的标记（其实生产代码可以打一些标记），所以只能抛弃这个本以为很简单的方法，该用了set合集去记录要设置0行列的行号或者列号，这个复杂度并不是很复杂，但是执行完发现代码的效率还是很低，先放代码：12345678910111213141516171819202122232425class Solution &#123; public void setZeroes(int[][] matrix) &#123; int R = matrix.length; int C = matrix[0].length; Set&lt;Integer&gt; rows = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; cols = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; R; i++) &#123; for (int j = 0; j &lt; C; j++) &#123; if (matrix[i][j] == 0) &#123; rows.add(i); cols.add(j); &#125; &#125; &#125; for (int i = 0; i &lt; R; i++) &#123; for (int j = 0; j &lt; C; j++) &#123; if (rows.contains(i) || cols.contains(j)) &#123; matrix[i][j] = 0; &#125; &#125; &#125; &#125;&#125; 代码低效的原因在于动用了两层循环，时间复杂度非常低，题目的置0是有规律的，不是无规律的，所以我开始寻求更新简单的方法,先贴最优解，要睡觉了，我的头发啊 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public void setZeroes(int[][] matrix) &#123; int R = matrix.length; int C = matrix[0].length; boolean isCol = false; for(int i=0; i&lt;R; i++) &#123; if (matrix[i][0] == 0) &#123; isCol = true; &#125; for(int j=1; j&lt;C; j++) &#123; if(matrix[i][j]==0) &#123; matrix[0][j] = 0; matrix[i][0] = 0; &#125; &#125; &#125; // Iterate over the array once again and using the first row and first column, update the elements. for(int i=1; i&lt;R; i++) &#123; for(int j=1; j&lt;C; j++) &#123; if(matrix[i][0]==0 || matrix[0][j]==0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; // See if the first row needs to be set to zero as well if(matrix[0][0]==0) &#123; for(int j=0; j&lt;C; j++) &#123; matrix[0][j] = 0; &#125; &#125; // See if the first column needs to be set to zero as well if(isCol) &#123; for(int i=0; i&lt;R; i++) &#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"2020-01-09-RedisTransaction","slug":"2020-01-09-RidisTransaction","date":"2020-01-09T14:42:06.000Z","updated":"2020-01-15T14:05:40.329Z","comments":true,"path":"2020/01/09/2020-01-09-RidisTransaction/","link":"","permalink":"http://zehai.info/2020/01/09/2020-01-09-RidisTransaction/","excerpt":"","text":"官网doc：https://redis.io/topics/transactions 本文纯属阅读笔记，无学术参考价值 what事务（transaction）的本质就是处理好几个动作，要么都成功，要么其中一个失败就全部回滚 每门语言都会有事务的支持，node也有async的方法实现事务几个动作串行，或者并行，一个失败全部回滚，之前写过支付的例子，使用async.waterfall,购买会员后 1.查询支付宝返回支付是否成功 2.获取用户所买会员的等级及相关权限 3.将权益插入用户表中 4.将订单数据记录到订单表中，方便后台查看订单量 大致步骤就是这些 Redis主要使用MULTI ,EXEC,DISCARD WATCH来实现事务的功能 遵循以下原则： 所有命令被序列化后顺序执行，且执行期间不接受其他请求，保证隔离性 EXEC命令触发事务中所有命令的执行，因此，如果客户端调用MULTI命令之前失去连接，则不执行任何操作。如果EXEC命令调用过，则所有的命令都会被执行 howMULTI输入事务以OK答复，此时用户可以发送多个命令，Redis都不会执行，而是排队，一旦调用EXEC，则将会执行所有命令，调用DISCARD将刷新（Flush？清空？重新执行？）事务队列并退出事务 示例代码： 123456789&gt; MULTIOK&gt; INCR fooQUEUED&gt; INCR barQUEUED&gt; EXEC1) (integer) 12) (integer) 1 可以看出EXEC返回一个数组，其中每个元素都是事务中单个命令的答复，其发出顺序与命令相同 当Reids连接处于MULTI的请求时，所有的命令都将以字符串queued答复，当EXEC时，将顺序执行 errors可能存在两种命令错误： 命令可能无法排队，因此在EXEC之前可能有错误（包括命令语法错误） 调用EXEC后，命令执行失败 客户端通过检查已排队（queued）的命令返回值来判断第一种错误，另外从2.6.5开始，服务器将记住在命令排队期间发生的错误，并且拒绝执行事务，返回错误并自动丢弃事务 EXEC执行后错误不会特殊处理，所有的命令都将被执及时有些命令失败 12345678910MULTI+OKSET a abc+QUEUEDLPOP a+QUEUEDEXEC*2+OK-ERR Operation against a key holding the wrong kind of value 即时命令失败，队列里的其他命令也会处理 1234&#123; name:stu time:1&#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"http://zehai.info/categories/Redis/"}],"tags":[{"name":"Transaction","slug":"Transaction","permalink":"http://zehai.info/tags/Transaction/"}]},{"title":"2020-01-08-SortColors","slug":"2020-01-08-SortColors","date":"2020-01-08T14:42:06.000Z","updated":"2020-01-09T15:11:01.324Z","comments":true,"path":"2020/01/08/2020-01-08-SortColors/","link":"","permalink":"http://zehai.info/2020/01/08/2020-01-08-SortColors/","excerpt":"","text":"Leetcode-75123456789101112131415Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.Note: You are not suppose to use the library&apos;s sort function for this problem.Example:Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0&apos;s, 1&apos;s, and 2&apos;s, then overwrite array with total number of 0&apos;s, then 1&apos;s and followed by 2&apos;s.Could you come up with a one-pass algorithm using only constant space? solution题目乍一看非常简单,但确实说使用简单的sort方法以及o(n^2)的排序确实会浪费时间复杂度，本着好奇心，我试了一下，果然成了吊车尾 1234567891011121314class Solution &#123; public void sortColors(int[] nums) &#123; for(int i =0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]&gt;nums[j])&#123; int tmp=nums[i]; nums[i]=nums[j]; nums[j]=tmp; &#125; &#125; &#125; &#125;&#125;Runtime: 1 ms, faster than 6.35% of Java online submissions for Sort Colors. 该题优化的核心位置是该数组是一个一维数组，设置两个指针，左边遍历0，遇到0往左放，遇到2往右放，r和l为左右分界线，index记录最后一个0的位置1234567891011121314151617181920212223242526272829class Solution &#123; public void sortColors(int[] nums) &#123; int l = 0; int r = nums.length - 1; int index = 0; while(l &lt;= r) &#123; if(nums[l] == 0) &#123; if(l &gt; index) &#123; int tmp = nums[index]; nums[index] = nums[l]; nums[l] = tmp; index++; &#125; else &#123; l++; index++; &#125; &#125; else if(nums[l] == 2) &#123; int tmp = nums[r]; nums[r] = 2; nums[l] = tmp; r--; &#125; else l++; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"2020-01-08-MinimunPathSum","slug":"2020-01-08-MinimumPathSum","date":"2020-01-08T14:42:06.000Z","updated":"2020-01-09T15:11:05.059Z","comments":true,"path":"2020/01/08/2020-01-08-MinimumPathSum/","link":"","permalink":"http://zehai.info/2020/01/08/2020-01-08-MinimumPathSum/","excerpt":"","text":"Leetcode-641234567891011121314Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time.Example:Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. solution解法为简单的动态规划，只要找到比较该元素，上方和左方的值的最小值，然后与该值相加，就可以得到解 123456789101112class Solution &#123; public int minPathSum(int[][] grid) &#123; for(int i=1; i&lt;grid.length; i++) grid[i][0] += grid[i-1][0]; for(int j=1; j&lt;grid[0].length; j++) grid[0][j] += grid[0][j-1]; for (int i=1; i&lt;grid.length; i++) &#123; for (int j=1; j&lt;grid[0].length; j++) &#123; grid[i][j] = Math.min(grid[i][j-1], grid[i-1][j]) + grid[i][j]; &#125; &#125; return grid[grid.length-1][grid[0].length-1]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"2020-01-07-关于Promise的思考","slug":"2020-01-07-关于Promise的思考","date":"2020-01-07T14:42:06.000Z","updated":"2020-01-08T08:36:47.390Z","comments":true,"path":"2020/01/07/2020-01-07-关于Promise的思考/","link":"","permalink":"http://zehai.info/2020/01/07/2020-01-07-关于Promise的思考/","excerpt":"","text":"题目（这道题在互联网上已经有了） 123可以添加任务，任务包含任务数据，任务延迟触发的等待时间。在任务到达触发时间点时，自动触发执行此任务。队列中任务保持先进先出原则：假设 A 任务的触发等待时间为 X，B 任务的触发等待时间为 Y，B 在 A 之后被添加入队列，则 A 的前驱任务执行完成后等待时间 X 后，才执行 A，同理在 A 执行完成后，等待时间 Y，才执行 B。 思路过程1.Java上线读题目就是延时队列的特征，Java有锁，有多线程，写起来多方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.concurrent.BlockingQueue;import java.util.concurrent.DelayQueue;import java.util.concurrent.Delayed;import java.util.concurrent.TimeUnit;public class HandWritingQueue &#123; public static void main(String[] args) &#123; final BlockingQueue&lt;DelayedElement&gt; deque = new DelayQueue&lt;&gt;(); Runnable producerRunnable = new Runnable() &#123; int i = 10; public void run() &#123; while (true &amp;&amp; i&gt;0) &#123; try &#123; --i; System.out.println(\"producing \"+i+\",wait \"+i+\" seconds\"); deque.put(new DelayedElement(1000 * i, \"i=\" + i)); Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable customerRunnable = new Runnable() &#123; public void run() &#123; while (true) &#123; try &#123; System.out.println(\"consuming:\" + deque.take().msg); //Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Runnable getSize= new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println(\"size=\"+deque.size()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread1 = new Thread(producerRunnable); thread1.start(); Thread thread2 = new Thread(customerRunnable); thread2.start(); Thread thread3 = new Thread(getSize); thread3.start(); &#125; static class DelayedElement implements Delayed &#123; private final long expire; private final String msg; public DelayedElement(long delay, String msg) &#123; this.msg = msg; expire = System.currentTimeMillis() + delay; &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(this.expire - System.currentTimeMillis(), TimeUnit.MILLISECONDS); &#125; @Override public int compareTo(Delayed o) &#123; return -1;//FIFO &#125; &#125;&#125; 2.Node上线被提醒该题目可以用node实现，且不需要借助redis来做，然后我上手就是一把操作： 123456789101112131415161718192021222324'use strict'class DelayElement &#123; constructor(data, expire) &#123; this.data = data; this.expire = expire;//second &#125;&#125;const delayArray = [];//push two element in delayArraydelayArray.push(new DelayElement(1, 2));delayArray.push(new DelayElement(2, 1));let length = delayArray.length;let time_cnt = 0;while (delayArray.length &gt; 0) &#123; let de = delayArray.shift(); time_cnt += de.expire;//serial (function () &#123; setTimeout(() =&gt; &#123; console.log('expire data is :' + de.data + ',expire time is :' + de.expire); &#125;, time_cnt * 1000); &#125;)();&#125; 我以为设计的考点也就是立即执行函数，延时的使用，但是这里的for循环是个伪串行，实际上是并发的，也为第三步的修改提供了bug 3.Promise时代一开始我是想把async函数放进去，写了如下的代码： 1234567891011121314151617'use strict'const delayArray = [];const daPush = (data, expire) =&gt; &#123; delayArray.push(async () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('data is ' + data + ' and expire is ' + expire); &#125;, expire * 1000); &#125;);&#125;daPush(1, 4);//2 secondsdaPush(2, 5);(async () =&gt; &#123; for (const da of delayArray) &#123; await da(); &#125;&#125;)(); 发现代码还是串行的，然后查了一下可能的问题（以下为个人猜测，欢迎指正）async声明的函数会包装成Promise不假，但是for循环会并发去执行await中的async 4.正解 promise执行会阻塞主线程 Macrotasks和Microtasks 都属于上述的异步任务中的一种，他们分别有如下API：macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promise, MutationObserver 任务队列中，在每一次事件循环中，macrotask只会提取一个执行，而microtask会一直提取，直到microsoft队列为空为止。 也就是说如果某个microtask任务被推入到执行中，那么当主线程任务执行完成后，会循环调用该队列任务中的下一个任务来执行，直到该任务队列到最后一个任务为止。 而事件循环每次只会入栈一个macrotask,主线程执行完成该任务后又会检查microtasks队列并完成里面的所有任务后再执行macrotask的任务。 以及macrotask应该对应的是check队列（该行未验证） 123456789101112131415161718192021222324252627282930'use strict'const delayArray = [];const daPush = (data, expire) =&gt; &#123; delayArray.push(() =&gt; new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; if(data) &#123; console.log('data is ' + data + ' and expire is ' + expire); resolve(true); &#125; else&#123; reject('there is nodata'); &#125; &#125;, expire * 1000); &#125;));&#125;;daPush(1, 4);//2 secondsdaPush(2, 5);(async () =&gt; &#123; for (const da of delayArray) &#123; da().then((value)=&gt;&#123; // console.log(value); &#125;).catch((value)=&gt;&#123; console.log(value); &#125;); //没有28-33，只35行也可以 // await da(); &#125;&#125;)();","categories":[],"tags":[]},{"title":"2020-01-07-SetTimeout","slug":"2020-01-07-SetTimeout","date":"2020-01-07T05:01:52.000Z","updated":"2020-01-07T15:33:02.795Z","comments":true,"path":"2020/01/07/2020-01-07-SetTimeout/","link":"","permalink":"http://zehai.info/2020/01/07/2020-01-07-SetTimeout/","excerpt":"","text":"执行了一下程序： 12345while(true)&#123; setTimeout(()=&gt;&#123; console.log(1) &#125;,0)&#125; 返回了一下内容： 123456789101112131415161718192021222324252627&lt;--- Last few GCs ---&gt;[12308:000001E565C2F6F0] 14167 ms: Mark-sweep 1395.9 (1425.2) -&gt; 1395.9 (1423.7) MB, 1754.1 / 0.0 ms (+ 0.0 ms in 39 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1764 ms) (average mu = 0.105, current mu = 0.020) a[12308:000001E565C2F6F0] 14175 ms: Scavenge 1397.3 (1423.7) -&gt; 1397.3 (1425.2) MB, 7.0 / 0.0 ms (average mu = 0.105, current mu = 0.020) allocation failure&lt;--- JS stacktrace ---&gt;==== JS stack trace ========================================= 0: ExitFrame [pc: 000002AFCABDC5C1]Security context: 0x037b5391e6e9 &lt;JSObject&gt; 1: /* anonymous */ [0000016D4360B9A1] [D:\\working\\h3yun\\test.3.js:~1] [pc=000002AFCAC7210F](this=0x016d4360bad1 &lt;Object map = 000001F79EE82571&gt;,exports=0x016d4360bad1 &lt;Object map = 000001F79EE82571&gt;,require=0x016d4360ba91 &lt;JSFunction require (sfi = 00000397F3EC6A31)&gt;,module=0x016d4360ba09 &lt;Module map = 000001F79EED3DA1&gt;,__filename=0x0397f3ece219 &lt;Strin...FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory 1: 00007FF7C7BFC6AA v8::internal::GCIdleTimeHandler::GCIdleTimeHandler+4506 2: 00007FF7C7BD7416 node::MakeCallback+4534 3: 00007FF7C7BD7D90 node_module_register+2032 4: 00007FF7C7EF189E v8::internal::FatalProcessOutOfMemory+846 5: 00007FF7C7EF17CF v8::internal::FatalProcessOutOfMemory+639 6: 00007FF7C80D7F94 v8::internal::Heap::MaxHeapGrowingFactor+9620 7: 00007FF7C80CEF76 v8::internal::ScavengeJob::operator=+24550 8: 00007FF7C80CD5CC v8::internal::ScavengeJob::operator=+17980 9: 00007FF7C80D6317 v8::internal::Heap::MaxHeapGrowingFactor+232710: 00007FF7C80D6396 v8::internal::Heap::MaxHeapGrowingFactor+245411: 00007FF7C8200637 v8::internal::Factory::NewFillerObject+5512: 00007FF7C827D826 v8::internal::operator&lt;&lt;+7349413: 000002AFCABDC5C1 why因为业务代码阻塞住，没有进入timer_handler的循环，所以1虽然进入了timer的红黑树中，但是不可能输出，不像之前for循环会有一个截止条件，后续的定时器还是可以生效的 另外有一个地方记混了，遍历回调的时候，会执行直到回调为空或者最大执行回调数量，而业务代码只会在这里阻塞不会停止，这也是为何出现GC的日志 whatsetimeout是JS前端常用的控件用来延时执行一个函数（回调），当执行业务代码的时候我们会将settimeout，setImmediate，nextTick，setInterval插入timer_handler的不同队列中（详见左侧node分支，且文章也在更新中），当JS单线程执行完业务代码后，才开始eventloop查找观察者来进行回调，当然也存在延时不精确的可能","categories":[],"tags":[]},{"title":"2020-01-06-gRPC","slug":"2020-01-06-gRPC","date":"2020-01-06T12:55:51.000Z","updated":"2020-01-06T14:55:50.255Z","comments":true,"path":"2020/01/06/2020-01-06-gRPC/","link":"","permalink":"http://zehai.info/2020/01/06/2020-01-06-gRPC/","excerpt":"","text":"whygRPC是任何环境都可以运行的高性能开源框架，他可以通过pluggable support来高效实现负载均衡，心跳检测和授权，他也可以应用于分布式计算的最后一个流程（连接各个端到后端） 简单的服务定义 快速启动易扩展 跨语言，跨平台 双向流和鉴权 feature gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件。关于protobuf可以参见笔者之前的小文Google Protobuf简明教程 另外，通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。 gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用。） node123456$ # Clone the repository to get the example code$ git clone -b v1.25.0 https://github.com/grpc/grpc$ # Navigate to the dynamic codegen &quot;hello, world&quot; Node example:$ cd grpc/examples/node/dynamic_codegen$ # Install the example&apos;s dependencies$ npm install","categories":[{"name":"gRPC","slug":"gRPC","permalink":"http://zehai.info/categories/gRPC/"}],"tags":[{"name":"network","slug":"network","permalink":"http://zehai.info/tags/network/"}]},{"title":"2020-01-03-SearchInsertPosition","slug":"2020-01-03-SearchInsertPosition","date":"2020-01-03T09:01:03.000Z","updated":"2020-01-03T09:23:21.572Z","comments":true,"path":"2020/01/03/2020-01-03-SearchInsertPosition/","link":"","permalink":"http://zehai.info/2020/01/03/2020-01-03-SearchInsertPosition/","excerpt":"","text":"LeetCode38Easy Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 离职后的第一题想先简单点热个身（后面有个难的目前还没做出来），就是说给一个target，返回它在数组中的位置 How该题目一上脑子就可以写下如下的代码 12345678910111213141516public int searchInsert(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return 0; &#125; if (target &gt; nums[nums.length - 1]) &#123; return nums.length; &#125; int pos =1; for(int i =0;i&lt;nums.length-1;i++)&#123; if(nums[i]&lt;target &amp;&amp; nums[i+1]&gt;=target)&#123; pos = ++i; break; &#125; &#125; return pos;&#125; 但转念一想，题目中给定的是一个sorted array这是一个优化的切口，可以将O(n)的复杂度降低到O(logn),通过递归来拆解完成这道题 12345678910111213141516171819private int searchInsert(int[] nums, int target, int low, int high) &#123; int mid = (low+high)/2; if (target &lt; nums[mid]) &#123; if (mid == 0 || target &gt; nums[mid-1]) &#123; return mid; &#125; return searchInsert(nums, target, low, mid-1); &#125; if (target &gt; nums[mid]) &#123; if (mid == nums.length-1 || target &lt; nums[mid+1]) &#123; return mid+1; &#125; return searchInsert(nums, target, mid+1, high); &#125; return mid; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://zehai.info/tags/easy/"}]},{"title":"2019-12-22-zookeeper概要","slug":"2019-12-22-zookeeper概要","date":"2019-12-16T12:37:30.000Z","updated":"2019-12-22T06:08:56.344Z","comments":true,"path":"2019/12/16/2019-12-22-zookeeper概要/","link":"","permalink":"http://zehai.info/2019/12/16/2019-12-22-zookeeper概要/","excerpt":"","text":"含义：动物管理员，管理节点 作用：开源的分布式应用程序协调服务（简单来说，就是一个抽象出来，专门管理各个服务的管理员，发现服务，注册服务，以实现分布式应用的联合工作） feature 树状目录结构，节点称作znode 持久节点（客户端断开仍然存在） 临时节点（断开消失） 节点监听（通过get exists,getchildren来实行监听） 应用： 分布式锁 描述 问题场景 我们有一个服务C，将A系统的订单数据，发送到B系统进行财务处理，但这个服务部C署了三个服务器来进行并发，其中有些数据在传送处理时会new一个objectid，如果不添加锁，该数据可能被两个服务同时调起，在B服务中生成两条记录 解决方案 我们同步数据时候，需要给同一个数据加锁，防止该数据同时被两个服务调起，服务访问某条订单数据时候，需要先获得锁，操作完后释放锁 实现方式 每个服务连接一个znode的下属有序临时节点，并监听上个节点的变化，编号最小的临时节点获得锁，操作资源，来实现 服务注册和发现 问题场景 我们同步数据的服务C（上个表格中描述）,可能是部署在一个机器上的多进程，也可能是部署在多个物理ip上的服务，他是动态变化的，如果没有zookeeper类的软件，可能我每改一次ip，都需要重启一下服务，服务宕机了，也要改ip（不然404） 解决方案 我们需要有个服务来管理应用状态，知道服务的运行状态，这样，当其他服务调起这个服务的时候，才能通过zookeeper提供的地址进行同行 实现方式 服务启动会注册到zookeeper，并保持心跳，其他服务想要调用某服务的时候，询问zookeeper拿到地址，然后发送请求报文（例如RPC） 1.每个应用创建一个持久节点，每个服务在持久节点下建立临时节点，不同应用间会有监听，A服务如果变动，B服务会收到订阅","categories":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://zehai.info/categories/zookeeper/"}],"tags":[{"name":"introduction","slug":"introduction","permalink":"http://zehai.info/tags/introduction/"}]},{"title":"2019-12-22-SpringBoot概要","slug":"2019-12-22-SpringBoot概要 ","date":"2019-12-16T12:37:30.000Z","updated":"2019-12-22T06:33:11.205Z","comments":true,"path":"2019/12/16/2019-12-22-SpringBoot概要 /","link":"","permalink":"http://zehai.info/2019/12/16/2019-12-22-SpringBoot概要 /","excerpt":"","text":"含义：spring 的简化配置版本（继承父类依赖，拥有父类的所有配置） 123456789101112131415&lt;!--你的项目pom文件--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;!--点开spring-boot-starter-parent，文件相对位置\\org\\springframework\\boot\\spring-boot-starter-parent\\2.0.4.RELEASE--&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 微服务 AOP 简化部署，可以再pom.xml中配置plugins来实现导出jar包，方便执行 Features: starter 入口类标记@SpringBootApplication SpringBoot配置类@SpringBootConfiguration 配置类@Configuration 开启自动配置@EnableAutoConfiguration 自动配置包@AutoConfigurationPackage 导入组件@Import 疑惑 为什么使用注解 为什么需要AOP 为什么选择springboot","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zehai.info/categories/SpringBoot/"}],"tags":[{"name":"introduction","slug":"introduction","permalink":"http://zehai.info/tags/introduction/"}]},{"title":"2019-12-15-@SpringBootApplication","slug":"2019-12-15-SpringBootApplication","date":"2019-12-15T15:13:51.000Z","updated":"2019-12-15T16:06:06.152Z","comments":true,"path":"2019/12/15/2019-12-15-SpringBootApplication/","link":"","permalink":"http://zehai.info/2019/12/15/2019-12-15-SpringBootApplication/","excerpt":"","text":"启动类我们可以见到最简单的springboot的application.java文件如下123456@SpringBootApplicationpublic class SpringTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringTestApplication.class, args); &#125; 实际上，SpringApplication的run方法时首先会创建一个SpringApplication类的对象，利用构造方法创建SpringApplication对象时会调用initialize方法 1234567891011public static ConfigurableApplicationContext run(Object source, String... args) &#123; return run(new Object[] &#123; source &#125;, args); &#125; public static ConfigurableApplicationContext run(Object[] sources, String[] args) &#123; return new SpringApplication(sources).run(args); &#125; public SpringApplication(Object... sources) &#123; initialize(sources); &#125; 其中initialize方法如下 1234567891011121314151617`private void initialize(Object[] sources) &#123; // 在sources不为空时，保存配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; // 判断是否为web应用 this.webEnvironment = deduceWebEnvironment(); // 获取并保存容器初始化类，通常在web应用容器初始化使用 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的ApplicationContextInitializer setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); // 获取并保存监听器 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 从堆栈信息获取包含main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 实例化后调用run： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; // 配置属性 configureHeadlessProperty(); // 获取监听器 // 利用loadFactoryNames方法从路径MEAT-INF/spring.factories中找到所有的SpringApplicationRunListener SpringApplicationRunListeners listeners = getRunListeners(args); // 启动监听 // 调用每个SpringApplicationRunListener的starting方法 listeners.starting(); try &#123; // 将参数封装到ApplicationArguments对象中 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); // 准备环境 // 触发监听事件——调用每个SpringApplicationRunListener的environmentPrepared方法 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 从环境中取出Banner并打印 Banner printedBanner = printBanner(environment); // 依据是否为web环境创建web容器或者普通的IOC容器 context = createApplicationContext(); analyzers = new FailureAnalyzers(context); // 准备上下文 // 1.将environment保存到容器中 // 2.触发监听事件——调用每个SpringApplicationRunListeners的contextPrepared方法 // 3.调用ConfigurableListableBeanFactory的registerSingleton方法向容器中注入applicationArguments与printedBanner // 4.触发监听事件——调用每个SpringApplicationRunListeners的contextLoaded方法 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 刷新容器，完成组件的扫描，创建，加载等 refreshContext(context); afterRefresh(context, applicationArguments); // 触发监听事件——调用每个SpringApplicationRunListener的finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; // 返回容器 return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 为了建立调用逻辑画了一张图，比较粗糙 总结SpringApplication.run一共做了两件事 创建SpringApplication对象；在对象初始化时保存事件监听器，容器初始化类以及判断是否为web应用，保存包含main方法的主配置类。 调用run方法；准备spring的上下文，完成容器的初始化，创建，加载等。会在不同的时机触发监听器的不同事件 https://www.cnblogs.com/davidwang456/p/5846513.html","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://zehai.info/categories/SpringBoot/"}],"tags":[{"name":"annotation","slug":"annotation","permalink":"http://zehai.info/tags/annotation/"}]},{"title":"2019-12-14-分布式系统","slug":"2019-12-14-分布式系统","date":"2019-12-14T07:41:03.000Z","updated":"2019-12-14T08:54:29.765Z","comments":true,"path":"2019/12/14/2019-12-14-分布式系统/","link":"","permalink":"http://zehai.info/2019/12/14/2019-12-14-分布式系统/","excerpt":"","text":"[TOC] 分布式锁原因：目的： 数据库唯一索引redis 的SETNXredis的RedLock分布式事务CAPBASEPaxosRaft","categories":[{"name":"Distribution","slug":"Distribution","permalink":"http://zehai.info/categories/Distribution/"}],"tags":[{"name":"KnowageTree","slug":"KnowageTree","permalink":"http://zehai.info/tags/KnowageTree/"}]},{"title":"2019-10-27-DynamicProgramming动态规划","slug":"2019-10-27-DynamicProgramming动态规划","date":"2019-10-27T04:01:05.000Z","updated":"2019-10-27T04:07:41.509Z","comments":true,"path":"2019/10/27/2019-10-27-DynamicProgramming动态规划/","link":"","permalink":"http://zehai.info/2019/10/27/2019-10-27-DynamicProgramming动态规划/","excerpt":"","text":"what动态规划是通过组合子问题的解里求解原问题，一般被用来求最优化问题 1.刻画一个最优解的结构特征 2.递归定义最优解的值 3.计算最优解 4.计算的信息构造最优解","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://zehai.info/categories/Algorithms/"}],"tags":[{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"http://zehai.info/tags/DynamicProgramming/"}]},{"title":"2019-09-21-中台是什么","slug":"2019-09-21-中台是什么","date":"2019-09-21T01:54:06.000Z","updated":"2019-09-21T02:10:36.635Z","comments":true,"path":"2019/09/21/2019-09-21-中台是什么/","link":"","permalink":"http://zehai.info/2019/09/21/2019-09-21-中台是什么/","excerpt":"","text":"why公司最近上了一套中台服务，因为好奇所以查了一下资料，中台是为了提高开发效率，将各个服务中共同的组织，资源集中管理，作为一个整体服务，宏观上我们可以把淘宝客户端，盒马生鲜，饿了么看做大前端，而他们有一部分共享数据，比如用户信息，支付功能，搜索功能等 又比如我们公司的电商平台，核心系统包括，ERP（企业资源计划即 ERP Enterprise Resource Planning），WMS（仓库管理系统Warehouse Management System）以及一套交付系统（包含购买，安装服务，维修服务，代理商管理等），他们需要共享商品信息，ERP需要用来算账，WMS需要用来发货，交付系统需要用来记录他的生命周期，就在中台配置一套信息，就可以达到三套系统都可以访问的效果。 what中台也可以分类： 业务中台（如上举例我们公司的业务） 技术中台（如淘宝的中台，当然也有偏业务的部分，主要目的防止重复造轮子） 数据中台（包括建模，日志分析，profile） 算法中台（推荐算法，搜索算法等） feature目前中台还是比较烧钱的吧，公司没有到达一定的规模，这个东西还是没有什么卵用，我们目前上了一套ERP，一套中台，级别在千万吧，还需要各个部门进行配合，进行系统整合（以前都是各干各的，系统间几乎没有交互，重复造轮子）。恶心的我啊，加了10117了三个月才大体上能用了 不过我觉得中台的发展历史可能和服务一样，一个整体的服务臃肿，后续的中台还是会变成中心化，即一个核心业务，其他做成微服务，分布式的架构，是目前技术潮流的前进方向","categories":[{"name":"Java","slug":"Java","permalink":"http://zehai.info/categories/Java/"}],"tags":[]},{"title":"2019-09-14Node日志感受","slug":"2019-09-14-Node日志感受","date":"2019-09-14T12:33:37.000Z","updated":"2019-09-21T01:54:13.619Z","comments":true,"path":"2019/09/14/2019-09-14-Node日志感受/","link":"","permalink":"http://zehai.info/2019/09/14/2019-09-14-Node日志感受/","excerpt":"","text":"why日志是用来记录程序运行重要的工具 记录请求日志，关键节点打上日志，可以追踪问题（生产） 方便调试，定位故障 监控应用的运行状态 what(egg.js为例)日志分为： appLogger应用日志，也是我们自定义的日志 coreLogger核心框架，插件日志 errorLogger agentLogger用于监控agent日志 日志级别： ctx.logger.debug() ctx.logger.info() ctx.logger.warn() ctx.logger.error() 以appLogger为例，一共4*4种 日志编码： 默认utf-8 feature目前日志都支持切割，每天一个文件，以.log.2019-09-14为尾缀（小时切割和文件大小切割实用性不高），编写日志的时候我们也需要注意如下几点： 在关键请求关键位置打好日志 打印日志注明这是哪个文件哪个方法处理的日志 12logger.debug(`&gt;&gt;&gt;&gt; Entering yourMethod(month = $&#123;month&#125;, count= $&#123;count&#125;\");//通过日志 &gt;&gt;&gt;&gt; 和 &lt;&lt;&lt;&lt; 将给出函数输入和退出的信息 日志不能太多，一个是查问题日志太多，第二个是对硬盘写入日志也有一定性能影响（egg是写入内存，每秒保存一次硬盘） 合理使用try-catch来进行日志输出 日志写法一定要避免简洁，不要日志再抛错（正常打印参数，打印处理结果） 日志不能具备除了日志以外的功能 正确把握日志级别，info记录信息（最主要的），debug显示调试信息，warn显示警告，error保存数据库请求类型的报错 尽量使用ctx.logger而并非console.log，后者将会把所有日志打印在stdout中，无法关闭或打开调试信息，并且不区分级别","categories":[{"name":"Node","slug":"Node","permalink":"http://zehai.info/categories/Node/"}],"tags":[{"name":"logs","slug":"logs","permalink":"http://zehai.info/tags/logs/"}]},{"title":"2019-04-24-Nodejs12","slug":"2019-04-24-Nodejs12","date":"2019-04-24T15:13:10.000Z","updated":"2019-04-26T14:09:09.015Z","comments":true,"path":"2019/04/24/2019-04-24-Nodejs12/","link":"","permalink":"http://zehai.info/2019/04/24/2019-04-24-Nodejs12/","excerpt":"","text":"Introducing Node.js 12raw article Apr 24 This blog was written by Bethany Griggs and Michael Dawson, with additional contributions from the Node.js Release Team and Technical Steering committee. We are excited to announce Node.js 12 today. Highlighted updates and features include faster startup and better default heap limits, updates to V8, TLS, llhttp, new features including diagnostic report, bundled heap dump capability and updates to Worker Threads, N-API and ES6 module support and more. The Node.js 12 release replaces version 11 in our current release line. The Node.js release line will become a Node.js Long Term Support (LTS) release in Oct 2019 (more details on LTS strategy here). V8 Gets an Upgrade: V8 update to V8 7.4As always a new version of the V8 JavaScript engine brings performance tweaks and improvements as well as keeping Node.js up with the ongoing improvements in the language and runtime. Highlights include: Async stack traces: https://v8.dev/blog/v8-release-72#async-stack-traces Faster calls with arguments mismatch: https://v8.dev/blog/v8-release-74#faster-calls-with-arguments-mismatch Faster await: https://v8.dev/blog/v8-release-73#faster-await Faster javascript parsing: https://v8.dev/blog/v8-release-72#javascript-parsing Read more about V8 at their official blog. Hello TLS 1.3 Node.js 12 is introducing TLS1.3 support and making it the default max protocol, while also supporting CLI/NODE_OPTIONS switches to disable it if necessary. TLS1.3 is a major update to the TLS protocol, with many security enhancements and should be used over TLS1.2 whenever possible. TLS1.3 is different enough that even though the OpenSSL APIs are technically API/ABI compatible when TLS1.3 is negotiated, changes in the timing of protocol records and of callbacks broke assumptions hard-coded into the ‘tls’ module. This change introduces no API incompatibilities when TLS1.2 is negotiated. It is the intention that it be backported to current and LTS release lines with the default maximum TLS protocol reset to ‘TLSv1.2’. This will allow users of those lines to explicitly enable TLS1.3 if they want. If you want to read more you can check out these related articles:https://developer.ibm.com/blogs/openssl-111-has-landed-in-nodejs-master-and-why-its-important-for-nodejs-lts-releases/, https://developer.ibm.com/blogs/tls13-is-coming-to-nodejs/ Properly configure default heap limitsThis update will configure the JavaScript heap size based on available memory instead of using defaults that were set by V8 for use with browsers. In previous releases, unless configured, V8 defaulted to limiting the max heap size to 700 MB or 1400MB on 32 and 64-bit platforms respectively. Configuring the heap size based on available memory ensures that Node.js does not try to use more memory than is available and terminating when its memory is exhausted. This is particularly useful when processing large data-sets. As before, it will still be possible to set — max-old-space-size to use a different limit if the default is not appropriate for your application. Switch default http parser to llhttpNode.js 12 will also switch the default parser to llhttp. This will be beneficial in that it will make testing and comparing the new llhttp-based implementation easier. First introduced as llhttp experimental in v11.2.0, llhttp will be taken out of experimental in this release. Making Native Modules Easier — progress continuesNode.js 12 continues the trend of making building and supporting native modules easier. Changes include better support for native modules in combination with Worker threads, as well as N-API (https://nodejs.org/api/n-api.html#n_api_n_api) version 4 (which has also been backported to 8.x and 10.x) which makes it easier to use your own threads for native asynchronous functions. You can read more about this and how you can leverage it in your modules in this great article here: https://medium.com/the-node-js-collection/new-features-bring-native-add-ons-close-to-being-on-par-with-js-modules-cd4f9b8e4b4 Worker ThreadsWorker Threads (https://nodejs.org/api/worker_threads.html), while not new in this release, are still seeing progress. The use of Workers Threads no longer requires the use of a flag and they are progressing well towards moving out of experimental. While Node.js already performs well with the single-threaded event loop, there are some use-cases where additional threads can be leveraged for better results. We’d like you to try them out and let us know what use cases you have where they are helpful. For a quick introduction check out this great article: https://medium.com/@Trott/using-worker-threads-in-node-js-80494136dbb6. Diagnostic ReportsNode.js 12 brings with it a new experimental feature “Diagnostic report.” This allows you to generate a report on demand or when certain events occur. This report contains information that can be useful to help diagnose problems in production including crashes, slow performance, memory leaks, high CPU usage, unexpected errors and more. You can read more about it in this great article: https://medium.com/the-node-js-collection/easily-identify-problems-in-node-js-applications-with-diagnostic-report-dc82370d8029. Heap DumpsIf you ever needed to generate heap dumps in order to investigate memory issues but were slowed down by having to install a new module into production, the good news is that Node.js 12 brings integrated heap dump capability out of the box. You can check out the documentation in https://github.com/nodejs/node/pull/27133 and https://github.com/nodejs/node/pull/26501 to learn more. Startup ImprovementsIn Node.js 11 we shipped built-in code cache support in workers — when loading built-in libraries written in JavaScript, if the library was previously compiled on the main thread, the worker thread no longer needs to compile it from scratch but can reuse the v8 code cache generated by the main thread to speed up compilation. Similarly, the main thread can reuse the cache generated by workers. This gave a roughly 60% speedup for the startup of workers. Now in Node.js 12 we generate the code cache for built-in libraries in advance at build time, and embed it in the binary, so in the final release, the main thread can use the code cache to start up the initial load of any built-in library written in JavaScript. This gives a ~30% speedup in startup time for the main thread. ES6 Module SupportNode.js 12 brings an updated experimental version of support for ES6 modules. It is an important step toward a supported implementation and we’d like you to try it out and give us feedback. For more details check out this great blog post. New compiler and platform minimumsNode.js and V8 continue to embrace newer C++ features and take advantage of newer compiler optimizations and security enhancements. With the release of Node.js 12, the codebase now requires a minimum of GCC 6 and glibc 2.17 on platforms other than macOS and Windows. Binaries released at Node.js org use this new toolchain minimum and therefore include new compile-time performance and security enhancements. The increment in minimum compiler and libc requirements also increments minimums in supported platforms. Platforms using glibc (most platforms other than macOS and Windows) must now include a minimum version of 2.17. Common Linux platforms compatible with this version include Enterprise Linux 7 (RHEL and CentOS), Debian 8 and Ubuntu 14.04. Binaries available from nodejs.org will be compatible with these systems. Users needing to compile their own binaries on systems not natively supporting GCC 6 may need to use a custom toolchain. Even though Node.js 12.0.0 may compile with older compilers, expect the Node.js 12 codebase (including V8) to rapidly adopt C++ features supported by GCC 6 during the pre-LTS timeframe. Windows minimums remain the same as Node.js 11, requiring at least Windows 7, 2008 R2 or 2012 R2 and a minimum compiler of Visual Studio 2017. macOS users needing to compile Node.js will require a minimum of Xcode 8 and Node.js binaries made available on nodejs.org will only support a minimum of macOS 10.10 “Yosemite”. Further details are available in the Node.js BUILDING.md. Thank you!A big thank you to everyone who made this release come together, whether you submitted a pull request, helped with our benchmarking efforts, or you were in charge of one of the release versions. We’d also like to thank the Node.js Build Working Group for ensuring we have the infrastructure to create and test releases. The release manager for Node.js 12 is Bethany Griggs. For a full list of the release team members head here. You can read more about the complete list of features here. If you are interested in contributing to Node.js, we welcome you. Learn more via our contributor guidelines.","categories":[],"tags":[]},{"title":"2019-04-20-rentingHouse","slug":"2019-04-20-rentingHouse","date":"2019-04-20T15:23:38.000Z","updated":"2019-04-20T15:40:28.708Z","comments":true,"path":"2019/04/20/2019-04-20-rentingHouse/","link":"","permalink":"http://zehai.info/2019/04/20/2019-04-20-rentingHouse/","excerpt":"","text":"快要毕业了，朋友圈里洋溢着，毕业的快乐，直系学弟们也返校进行了毕业论文的最终答辩，也希望他们都取得一个好的成绩，能在回首大学四年时候，不因为碌碌无为而后悔，能够在社一中，找到一份合适的工作，并感谢曾经那个在大学奋斗的自己。 毕业季第一道坎就是租房（家里有矿的，这篇文章你就可以关掉了），总体来说，在京就业，房租确实很贵的，不过对于计算机专业来说，应该还是可以的。我们熟知的计算机区域 望京SOHO（小企业居多） 中关村 中关村软件园（大厂） 对应的租房地点可以选择： 孙河（就可能地铁站远一点） 上地附近 回龙观，朱辛庄 主要平台（按推荐顺序）： 自如（个人选择项，应届生有特权） 豆瓣小组 闲鱼 相如&gt;蛋壳=贝壳 应届生可能囊中羞涩，所以建议选择自如，分期月付（应届免押金，分起费120附近），不过计算机专业的应届生薪资理论上是&gt;=7k，所以我觉得应该马马虎虎可以生存下来了。之所以不推荐其他的中介，是因为你可能租房后，对于维修，舍友抽烟，养的宠物半夜狂叫，又退不了租，陷入麻烦中。（自如麻烦来结一下广告费） 另外整理一下招聘的软件（按推荐顺序）： （个人软件工程，仅供参考） BOSS 拉钩 智联招聘 脉脉 希望这些资料对刚毕业的你有所帮助，其余想起来的，再直接更新","categories":[],"tags":[]},{"title":"2019-04-17-日记","slug":"2019-04-17-日记","date":"2019-04-17T11:11:13.000Z","updated":"2019-04-18T13:19:51.650Z","comments":true,"path":"2019/04/17/2019-04-17-日记/","link":"","permalink":"http://zehai.info/2019/04/17/2019-04-17-日记/","excerpt":"","text":"经历了连续9*13小时的工作后，我终于得到了一天的调休计划，昨晚十一点半打车从五棵松到家 洗了个热水澡，关了手机闹铃，打开了Alexa的环境噪音，难的踏实的进入了梦中。 但是！！ 我Alexa的闹钟忘记关了，七点被吵醒后一直没有睡着，所以起床热了杯牛奶，弄了张煎饼，涂了点番茄酱就凑合吃了，后来外出和朋友聊了会儿天，倒确实点出了一些目前存在的问题 一个好的技术不仅要知其然，更要知其所以然，多挖掘他背后的源码，去思考如何实现，这样才能在高并发时，将200ms优化到100ms，才是一个高级程序员应该具备的素质之一 Node学习分为三年，第一年知其语法，会写应用，第二年知其框架，高级开发，第三年，读其源码，知其原理 多用语言去写一些工具类，多去学习和参考优质轮子，而不是写一些玩具，别人都写烂的东西 （重要的应该就这么多了） 朋友的话很对，我也进行了思考，自己在JS的道路上，摸着黑走路，对于源码其实要读，但是之前打开看过一眼就一脸懵逼的状态，所以还是需要有时间学习一下优质的GitHub，撕开一个口子，然后进入到正轨，自己去多写一些方法区调用，然后一点点去琢磨，他的实现过程。 4月底的计划就是 尽量换一份工作，受不了8117，薪资还不如麦当劳的临时工 自如租约到期了，搬家到朱辛庄或者霍营 没换工作的话，买一本书通勤看会儿，换工作的话，抽个零碎的时间读，顺便整理笔记，更博（暂定这个月读一下v8的gc） 五一出去旅游，暂时想去杭州看看 买点竹筒，想做竹筒饭","categories":[{"name":"life","slug":"life","permalink":"http://zehai.info/categories/life/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://zehai.info/tags/diary/"}]},{"title":"暂停更新通告[作废]","slug":"2019-04-13-暂停更新通告","date":"2019-04-13T14:03:36.000Z","updated":"2019-04-18T13:20:31.512Z","comments":true,"path":"2019/04/13/2019-04-13-暂停更新通告/","link":"","permalink":"http://zehai.info/2019/04/13/2019-04-13-暂停更新通告/","excerpt":"","text":"自今日起，博客开始停更 996.icu年后开始，互联网似乎过得都不好，从七陌被裁（也有个人原因吧），到被航天二院，知网，中电科因为学历卡住入职（BOSS直聘，面试完了，技术找人事审核不通过），后来遇到了一系列傲慢的中科软系列面试，无限加班的创业公司，还有那种以培训机构为目标招人的小公司。最终未能收获一个满意的offer，最终舔狗选择了一家说是不加班的某所，然，现在才发现，实在太忙，包括现在也刚刚到家，工作也没有pc，没有网络，所以也很不方便随时学习，可能有一些手写笔记，但经历有限，所以最近会停止更新 年后996冲上了榜首，让世界都在反思为什么中国的加班为什么如此疯狂，但话题热度很快下降，因为没有人会去放下手中的工作去抵制，毕竟生活总要继续下去 生活总是这样，起起落落落 努力不一定有回报，但不努力一定很（mei）舒（hui）服(bao) 晚安~hexo","categories":[],"tags":[]},{"title":"PermutationSequence-60","slug":"2019-04-09-PermutationSequence","date":"2019-04-09T13:09:28.000Z","updated":"2019-04-09T13:29:57.164Z","comments":true,"path":"2019/04/09/2019-04-09-PermutationSequence/","link":"","permalink":"http://zehai.info/2019/04/09/2019-04-09-PermutationSequence/","excerpt":"","text":"ProblemThe set [1,2,3,...,*n*] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; &quot;321&quot; Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1: 12Input: n = 3, k = 3Output: &quot;213&quot; Example 2: 12Input: n = 4, k = 9Output: &quot;2314&quot; keysolutionperfect","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://zehai.info/tags/medium/"}]},{"title":"https与http","slug":"2019-04-06-https与http","date":"2019-04-06T14:41:27.000Z","updated":"2019-04-06T14:43:42.055Z","comments":true,"path":"2019/04/06/2019-04-06-https与http/","link":"","permalink":"http://zehai.info/2019/04/06/2019-04-06-https与http/","excerpt":"","text":"whatadvantage客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。","categories":[],"tags":[]},{"title":"SpiralMatrix2-59","slug":"2019-04-06-SpiralMatrix2","date":"2019-04-06T08:16:18.000Z","updated":"2019-04-09T13:11:01.814Z","comments":true,"path":"2019/04/06/2019-04-06-SpiralMatrix2/","link":"","permalink":"http://zehai.info/2019/04/06/2019-04-06-SpiralMatrix2/","excerpt":"","text":"problem Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: 12345678&gt;Input: 3&gt;Output:&gt;[&gt; [ 1, 2, 3 ],&gt; [ 8, 9, 4 ],&gt; [ 7, 6, 5 ]&gt;]&gt; key虽然标了medium，但是确实很简单，形成一个口字型闭环，一层层去处理就好了，然后再主要就是控制口字循环时候的边界，以及最后一个元素的判断 solution12345678910111213141516171819202122232425262728public int[][] generateMatrix(int n) &#123; int [][]res = new int[n][n]; int left = 0; int right = n-1; int top = 0; int bottom = n-1; int index = 1; int quit = n*n; while(index&lt;=quit)&#123; for(int i=left;i&lt;=right;i++) &#123; res[top][i] = (index++); &#125; top++; for(int i=top;i&lt;=bottom;i++)&#123; res[i][right] = (index++); &#125; right--; for(int i=right;i&gt;=left;i--) &#123; res[bottom][i]=(index++); &#125; bottom--; for(int i=bottom;i&gt;=top;i--) &#123; res[i][left]=(index++); &#125; left++; &#125; return res; &#125; perfectno","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"medium","slug":"medium","permalink":"http://zehai.info/tags/medium/"}]},{"title":"LengthofLastWord","slug":"2019-04-06-LengthofLastWord","date":"2019-04-06T07:50:25.000Z","updated":"2019-04-06T14:43:46.865Z","comments":true,"path":"2019/04/06/2019-04-06-LengthofLastWord/","link":"","permalink":"http://zehai.info/2019/04/06/2019-04-06-LengthofLastWord/","excerpt":"","text":"problem Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 123&gt; Input: &quot;Hello World&quot;&gt; Output: 5&gt; key该方法调用了java的String.split(regex)所以在复杂度上回很高，大概仅仅beat了6%的玩家，但解决很快，正确的算法思维就倒序遍历，最后开始查往前，最后一个非空格查到空格结束 solution123456789101112//7mspublic int lengthOfLastWord(String s) &#123; if(s.length()&lt;=0)return 0; String[] tmp = s.split(\"\\\\s\"); int lastIndex = tmp.length-1; if(lastIndex&lt;0) &#123; return 0; &#125;else &#123; return tmp[lastIndex].length(); &#125; &#125; perfect1234567891011121314151617181920212223class Solution &#123; public int lengthOfLastWord(String s) &#123; int n = s.length() - 1; int length = 0; for(int i = n; i &gt;= 0; i--) &#123; if(length == 0) &#123; if(s.charAt(i) == &apos; &apos;) &#123; continue; &#125;else &#123; length++; &#125; &#125;else &#123; if(s.charAt(i) == &apos; &apos;) &#123; break; &#125; else &#123; length++; &#125; &#125; &#125; return length; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"easy","slug":"easy","permalink":"http://zehai.info/tags/easy/"}]},{"title":"eventLoop","slug":"2019-04-04-eventLoop","date":"2019-04-04T15:03:46.000Z","updated":"2019-04-05T02:53:03.481Z","comments":true,"path":"2019/04/04/2019-04-04-eventLoop/","link":"","permalink":"http://zehai.info/2019/04/04/2019-04-04-eventLoop/","excerpt":"","text":"whatEvent Loop是一个程序结构，用于等待和发送消息和事件 a programming construct that waits for and dispatches events or messages in a program. 简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。 由上图可以清楚知道Node的单线程指的是主线程为单线程 异步执行1234567// test.jssetTimeout(() =&gt; console.log(1));setImmediate(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));//异步最快Promise.resolve().then(() =&gt; console.log(4));(() =&gt; console.log(5))();//同步任务最早执行//53412 异步分为两种： 本轮循环：process.nextTick(),Promise 次轮循环:setTimeout(),setInterval,setImmediate 每一次循环中，setTimeout等次轮循环在timers阶段执行，而本轮循环就在check阶段执行，所以会先展示","categories":[],"tags":[]},{"title":"春节12响","slug":"2019-04-04-春节12响","date":"2019-04-04T14:15:52.000Z","updated":"2019-04-04T14:16:42.674Z","comments":true,"path":"2019/04/04/2019-04-04-春节12响/","link":"","permalink":"http://zehai.info/2019/04/04/2019-04-04-春节12响/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132// File: twelve_biubiu.c// Permission: CN-2082-2// Author: Li.YiYi// Dept: PE-362, UG// Origin: TI-352132// 春节十二响 biu biu biu!#env &quot;planet_engine&quot;int init() &#123; set_engine_number_mask(ENGINE_ALL); set_funeral_level(FUNERAL_FULL); // 允许误差10秒以内 if (unix_time() &lt; make_unix_time(2082, 1, 28, 23, 59, 60-10)) return ERR_ENGIN_ENV; return engine_check_init(); // after compile and before real run&#125;int main() &#123; set_curve(CURVE_NATURAL); // 自然曲线耗费燃料最少 for (int i :range(0, 12, 1)) &#123; engine_start(); wait_engine(ENGINE_STATE_CHAGNE); sleep(2000); engin_stop(); wait_engine(ENGINE_STATE_CHAGNE); sleep(4000); // 这个时长在模拟器里听起来更像心跳 &#125; return 0;&#125;int final() &#123; engine_ensure_shutdown();&#125;","categories":[{"name":"life","slug":"life","permalink":"http://zehai.info/categories/life/"}],"tags":[]},{"title":"各种Java中锁","slug":"2019-04-04-各种Java中锁","date":"2019-04-04T13:54:58.000Z","updated":"2019-04-04T14:15:30.272Z","comments":true,"path":"2019/04/04/2019-04-04-各种Java中锁/","link":"","permalink":"http://zehai.info/2019/04/04/2019-04-04-各种Java中锁/","excerpt":"","text":"悲观锁：先锁后用每次读数据都悲观认为会被其他操作修改，应用于synchroized , ReentrantLock，因为悲观所以开销大，会阻塞其他线程 乐观锁：先用后判断每次读数据乐观认为没有被其他操作修改，应用于java.util.concurrent.atomic,使用版本号和CAS算法实现 适用于多读的应用类型，提高吞吐量 公平锁：多个线程按申请所顺序取锁无 非公平锁多个线程不按申请顺序取锁，提高吞吐量 可入锁外层使用锁后，内层仍可以使用，而且不会死锁 不可重入锁独享锁共享锁互斥锁 读写锁 分段锁 偏向锁 轻量级锁 重量级锁 自旋锁","categories":[{"name":"Java","slug":"Java","permalink":"http://zehai.info/categories/Java/"}],"tags":[{"name":"lock","slug":"lock","permalink":"http://zehai.info/tags/lock/"}]},{"title":"MinStack","slug":"2019-03-24-MinStack","date":"2019-03-24T09:23:55.000Z","updated":"2019-03-24T09:24:55.784Z","comments":true,"path":"2019/03/24/2019-03-24-MinStack/","link":"","permalink":"http://zehai.info/2019/03/24/2019-03-24-MinStack/","excerpt":"","text":"problem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 123456789&gt; MinStack minStack = new MinStack();&gt; minStack.push(-2);&gt; minStack.push(0);&gt; minStack.push(-3);&gt; minStack.getMin(); --&gt; Returns -3.&gt; minStack.pop();&gt; minStack.top(); --&gt; Returns 0.&gt; minStack.getMin(); --&gt; Returns -2.&gt;","categories":[],"tags":[]},{"title":"FindMinimumInRotatedSortedArrayII","slug":"2019-03-23-FindMinimumInRotatedSortedArrayII","date":"2019-03-23T03:56:47.000Z","updated":"2019-04-06T07:53:34.315Z","comments":true,"path":"2019/03/23/2019-03-23-FindMinimumInRotatedSortedArrayII/","link":"","permalink":"http://zehai.info/2019/03/23/2019-03-23-FindMinimumInRotatedSortedArrayII/","excerpt":"","text":"problem Find Minimum in Rotated Sorted Array II Hard Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 123&gt;Input: [1,3,5]&gt;Output: 1&gt; Example 2: 123&gt;Input: [2,2,2,0,1]&gt;Output: 0&gt; Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? key??? solution12345678910class Solution &#123; public int findMin(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[0]; &#125;&#125; perfect","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Hard","slug":"Hard","permalink":"http://zehai.info/tags/Hard/"}]},{"title":"FindMinimumInRotatedSortedArray","slug":"2019-03-23-FindMinimumInRotatedSortedArray","date":"2019-03-23T03:53:07.000Z","updated":"2019-03-24T09:23:23.236Z","comments":true,"path":"2019/03/23/2019-03-23-FindMinimumInRotatedSortedArray/","link":"","permalink":"http://zehai.info/2019/03/23/2019-03-23-FindMinimumInRotatedSortedArray/","excerpt":"","text":"problem Find Minimum in Rotated Sorted Array Medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 123&gt;Input: [3,4,5,1,2] &gt;Output: 1&gt; Example 2: 123&gt;Input: [4,5,6,7,0,1,2]&gt;Output: 0&gt; keysolution12345678public int findMin(int[] nums) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[0]; &#125; perfect12I&apos;m the perfectbut this problem will harder in the next problem","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"安全防范","slug":"2019-03-23-安全防范","date":"2019-03-23T03:30:43.000Z","updated":"2019-03-23T03:32:29.938Z","comments":true,"path":"2019/03/23/2019-03-23-安全防范/","link":"","permalink":"http://zehai.info/2019/03/23/2019-03-23-安全防范/","excerpt":"","text":"分类 XSS 攻击：对 Web 页面注入脚本，使用 JavaScript 窃取用户信息，诱导用户操作。 CSRF 攻击：伪造用户请求向网站发起恶意请求。 钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。 HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。 远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。 XSS攻击cross-site-scripting跨域脚本攻击","categories":[{"name":"security","slug":"security","permalink":"http://zehai.info/categories/security/"}],"tags":[]},{"title":"mysql事务","slug":"2019-03-23-mysql事务","date":"2019-03-23T02:54:00.000Z","updated":"2019-03-23T03:30:13.735Z","comments":true,"path":"2019/03/23/2019-03-23-mysql事务/","link":"","permalink":"http://zehai.info/2019/03/23/2019-03-23-mysql事务/","excerpt":"","text":"whatMYSQL事务主要用于保证一串事情要么都成功，要么就回滚，例如付款后，要先写入支付订单表，再个人信息中加入会员权益。这两个操作要么顺序执行成功，要么就回滚 原则ACID Atomicity原子性 确保事务内的所有操作都成功完成，否则事务将被中止在故障点，以前的操作将回滚到以前的状态。 Consistency一致性 数据库的修改是一致的 Isolation隔离性 事务是彼此独立的 Durability可靠性 确保事务提交后，结果永久存在 隔离性 隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括 读未提交（Read uncommitted）–不严格 读提交（read committed） 可重复读（repeatable read）–默认级别（避免幻读） 串行化（Serializable）–最严格 没有隔离性的问题1.脏读12update account set money=money+100 where name=’B’;update account set money=money - 100 where name=’A’; 当执行第一条语句的时候，事务没有提交，那么来读B的账户钱都多了100块 脏读：读取了另一个事务未提交的数据 2.不可重复读情景：多次读同一个数据的时候，这个数据被别人改了，导致结果不一致 3.幻读幻读和不可重复读一样，读取到了另外一条已经提交的事务，所不同的是它针对的是一批数据的整体 实现方式自动方式beginTransactionScope(scope, ctx) 1234567const result = await app.mysql.beginTransactionScope(async conn =&gt; &#123; // don&apos;t commit or rollback by yourself await conn.insert(table, row1); await conn.update(table, row2); return &#123; success: true &#125;;&#125;, ctx); // if error throw on scope, will auto rollback 手动方式beginTransaction 12345678910const conn = await app.mysql.beginTransaction(); // 初始化事务try &#123; await conn.insert(table, row1); // 第一步操作 await conn.update(table, row2); // 第二步操作 await conn.commit(); // 提交事务&#125; catch (err) &#123; // error, rollback await conn.rollback(); // 一定记得捕获异常后回滚事务！！ throw err;&#125; 表达式Literalapp.mysql.literals.now 查看数据库事务隔离性级别 12&gt; select @@tx_isolation;&gt;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://zehai.info/categories/mysql/"}],"tags":[]},{"title":"bashrc","slug":"2019-03-15-bashrc","date":"2019-03-15T10:44:22.000Z","updated":"2019-03-15T10:47:32.113Z","comments":true,"path":"2019/03/15/2019-03-15-bashrc/","link":"","permalink":"http://zehai.info/2019/03/15/2019-03-15-bashrc/","excerpt":"","text":"where通常在home目录下的一个隐藏文件，访问可以1vim ~/.bashrc whatbash 在每次启动时都会加载 .bashrc 文件的内容。每个用户的 home 目录都有这个 shell 脚本。它用来存储并加载你的终端配置和环境变量 end12//更新修改source ~/.bashrc","categories":[],"tags":[]},{"title":"安装mysql服务以及常见问题解决","slug":"2019-03-14-ubuntu安装mysql服务以及常见问题解决","date":"2019-03-14T06:22:39.000Z","updated":"2019-03-15T10:44:25.707Z","comments":true,"path":"2019/03/14/2019-03-14-ubuntu安装mysql服务以及常见问题解决/","link":"","permalink":"http://zehai.info/2019/03/14/2019-03-14-ubuntu安装mysql服务以及常见问题解决/","excerpt":"","text":"安装sudo apt-get update sudo apt-get install mysql-server 解决远程连接 tips本人使用环境ubuntu16 完成安装后，远程连接你会发现2003报错，此时，你对 /etc/mysql/mysql.conf.d/ 文件夹中打开 mysqld.cnf文件修改即可 修改内容将#bind-address = 127.0.0.1 原本没有注释，进行注释 然后你重新远程连接mysql直接变成1130的拒绝访问服务，接下来你要在服务器端登录mysql，执行 进入数据库 mysql -u root -p 切换数据库, mysql&gt;use mysql; 查看root账号的登录权限, mysql&gt;select host, user from user; 修改登录权限 mysql&gt;update user set host = ‘%’ where user = ‘root’; 刷新,生效,最后一步,至关重要 mysql&gt;flush privileges;","categories":[],"tags":[]},{"title":"SpringbootMQ","slug":"2019-03-13-SpringbootMQ","date":"2019-03-13T13:11:53.000Z","updated":"2019-03-13T13:24:31.488Z","comments":true,"path":"2019/03/13/2019-03-13-SpringbootMQ/","link":"","permalink":"http://zehai.info/2019/03/13/2019-03-13-SpringbootMQ/","excerpt":"","text":"what is MQ如果想知道MQ的详细知识可以看我之前的为什么使用消息队列MQ 这里选择最重要的提一下：MQ即消息队列，用来实现程序的异步和解耦，起到消息缓冲，消息分发。通俗来讲就是一个医院（服务器）里面有多个医生（线程或进程），让病人都排队（消息缓冲），有的去A部门，有的去B部门（消息分发）。 成员RabbitMQRabbitMQ是实现AMQP（高级消息队列协议Advanced Message Queuing Protocol）的消息中间件的一种，Feature就是组件之间解耦，病人排他的队，医生看他的病人，至于怎么排，医生不用操心，至于怎么看病，病人不用操心，都交给MQ 术语：面向消息，队列，路由（点对点/发布订阅），可靠安全","categories":[{"name":"high_availability","slug":"high-availability","permalink":"http://zehai.info/categories/high-availability/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://zehai.info/tags/MQ/"}]},{"title":"Java问题排查工具","slug":"2019-03-13-Java问题排查工具","date":"2019-03-13T06:22:53.000Z","updated":"2019-03-13T08:57:51.644Z","comments":true,"path":"2019/03/13/2019-03-13-Java问题排查工具/","link":"","permalink":"http://zehai.info/2019/03/13/2019-03-13-Java问题排查工具/","excerpt":"","text":"一下文字摘自JAVA公众号 Linux命令类tail最常用的tail -f 1tail -300f shopbase.log #倒数300行并进入实时监听文件写入模式 grep12345678910grep forest f.txt #文件查找grep forest f.txt cpf.txt #多文件查找grep &apos;log&apos; /home/admin -r -n #目录下查找所有符合关键字的文件cat f.txt | grep -i shopbase grep &apos;shopbase&apos; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀grep &apos;shopbase&apos; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配seq 10 | grep 5 -A 3 #上匹配seq 10 | grep 5 -B 3 #下匹配seq 10 | grep 5 -C 3 #上下匹配，平时用这个就妥了cat f.txt | grep -c &apos;SHOPBASE&apos; awk1 基础命令 123456awk &apos;&#123;print $4,$6&#125;&apos; f.txtawk &apos;&#123;print NR,$0&#125;&apos; f.txt cpf.txt awk &apos;&#123;print FNR,$0&#125;&apos; f.txt cpf.txtawk &apos;&#123;print FNR,FILENAME,$0&#125;&apos; f.txt cpf.txtawk &apos;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&apos; f.txt cpf.txtecho 1:2:3:4 | awk -F: &apos;&#123;print $1,$2,$3,$4&#125;&apos; 2 匹配 1234awk &apos;/ldb/ &#123;print&#125;&apos; f.txt #匹配ldbawk &apos;!/ldb/ &#123;print&#125;&apos; f.txt #不匹配ldbawk &apos;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&apos; f.txt #匹配ldb和LISTENawk &apos;$5 ~ /ldb/ &#123;print&#125;&apos; f.txt #第五列匹配ldb 3 内建变量 NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。 FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。 NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。 find12345678910111213sudo -u admin find /home/admin /tmp /usr -name \\*.log(多个目录去找)find . -iname \\*.txt(大小写都匹配)find . -type d(当前目录下的所有子目录)find /usr -type l(当前目录下所有的符号链接)find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)find /home/admin f -perm 777 -exec ls -l &#123;&#125; \\; (按照权限查询文件)find /home/admin -atime -1 1天内访问过的文件find /home/admin -ctime -1 1天内状态改变过的文件 find /home/admin -mtime -1 1天内修改过的文件find /home/admin -amin -1 1分钟内访问过的文件find /home/admin -cmin -1 1分钟内状态改变过的文件 find /home/admin -mmin -1 1分钟内修改过的文件 pgm批量查询vm-shopbase满足条件的日志 1pgm -A -f vm-shopbase &apos;cat /home/admin/shopbase/logs/shopbase.log.2017-01-17|grep 2069861630&apos; tsartsar是咱公司自己的采集工具。很好用, 将历史收集到的数据持久化在磁盘上，所以我们快速来查询历史的系统数据。当然实时的应用情况也是可以查询的啦。大部分机器上都有安装。 1tsar ##可以查看最近一天的各项指标 1tsar --live ##可以查看实时指标，默认五秒一刷 1tsar -d 20161218 ##指定查看某天的数据，貌似最多只能看四个月的数据 1234tsar --memtsar --loadtsar --cpu##当然这个也可以和-d参数配合来查询某天的单个指标的情况 toptop除了看一些基本信息之外，剩下的就是配合来查询vm的各种问题了 12ps -ef | grep javatop -H -p pid 获得线程10进制转16进制后jstack去抓看这个线程到底在干啥 其他12netstat -nat|awk &apos;&#123;print $6&#125;&apos;|sort|uniq -c|sort -rn #查看当前连接，注意close_wait偏高的情况，比如如下 排查利器btrace首当其冲的要说的是btrace。真是生产环境&amp;预发的排查问题大杀器。 简介什么的就不说了。直接上代码干 查看当前谁调用了ArrayList的add方法，同时只打印当前ArrayList的size大于500的线程调用栈 @OnMethod(clazz = “java.util.ArrayList”, method=”add”, location = @Location(value = Kind.CALL, clazz = “/./“, method = “/./“))public static void m(@ProbeClassName String probeClass, @ProbeMethodName String probeMethod, @TargetInstance Object instance, @TargetMethodOrField String method) { 1234567if(getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance) &gt; 479)&#123; println(&quot;check who ArrayList.add method:&quot; + probeClass + &quot;#&quot; + probeMethod + &quot;, method:&quot; + method + &quot;, size:&quot; + getInt(field(&quot;java.util.ArrayList&quot;, &quot;size&quot;), instance)); jstack(); println(); println(&quot;===========================&quot;); println();&#125; } 监控当前服务方法被调用时返回的值以及请求的参数 @OnMethod(clazz = “com.taobao.sellerhome.transfer.biz.impl.C2CApplyerServiceImpl”, method=”nav”, location = @Location(value = Kind.RETURN))public static void mt(long userId, int current, int relation, String check, String redirectUrl, @Return AnyType result) { 1println(&quot;parameter# userId:&quot; + userId + &quot;, current:&quot; + current + &quot;, relation:&quot; + relation + &quot;, check:&quot; + check + &quot;, redirectUrl:&quot; + redirectUrl + &quot;, result:&quot; + result); } 其他功能集团的一些工具或多或少都有，就不说了。感兴趣的请移步。https://github.com/btraceio/btrace 注意: 经过观察，1.3.9的release输出不稳定，要多触发几次才能看到正确的结果 正则表达式匹配trace类时范围一定要控制，否则极有可能出现跑满CPU导致应用卡死的情况 由于是字节码注入的原理，想要应用恢复到正常情况，需要重启应用。 GreysGreys是@杜琨的大作吧。说几个挺棒的功能(部分功能和btrace重合): sc -df xxx: 输出当前类的详情,包括源码位置和classloader结构 trace class method: 相当喜欢这个功能! 很早前可以早JProfiler看到这个功能。打印出当前方法调用的耗时情况，细分到每个方法。对排查方法性能时很有帮助，比如我之前这篇就是使用了trace命令来的:http://www.atatech.org/articles/52947。 其他功能部分和btrace重合，可以选用，感兴趣的请移步。http://www.atatech.org/articles/26247 另外相关联的是arthas，他是基于Greys的，感兴趣的再移步http://mw.alibaba-inc.com/products/arthas/docs/middleware-container/arthas.wiki/home.html?spm=a1z9z.8109794.header.32.1lsoMc javOSize就说一个功能classes：通过修改了字节码，改变了类的内容，即时生效。 所以可以做到快速的在某个地方打个日志看看输出，缺点是对代码的侵入性太大。但是如果自己知道自己在干嘛，的确是不错的玩意儿。 其他功能Greys和btrace都能很轻易做的到，不说了。 可以看看我之前写的一篇javOSize的简介http://www.atatech.org/articles/38546官网请移步http://www.javosize.com/ JProfiler之前判断许多问题要通过JProfiler，但是现在Greys和btrace基本都能搞定了。再加上出问题的基本上都是生产环境(网络隔离)，所以基本不怎么使用了，但是还是要标记一下。官网请移步https://www.ej-technologies.com/products/jprofiler/overview.html 大杀器eclipseMAT可作为eclipse的插件，也可作为单独的程序打开。详情请移步http://www.eclipse.org/mat/ zprofiler集团内的开发应该是无人不知无人不晓了。简而言之一句话:有了zprofiler还要mat干嘛详情请移步zprofiler.alibaba-inc.com java三板斧，噢不对，是七把jps我只用一条命令： 1sudo -u admin /opt/taobao/java/bin/jps -mlvV jstack普通用法: 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack 2815 native+java栈: 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstack -m 2815 jinfo可看系统启动的参数，如下 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jinfo -flags 2815 jmap两个用途 1.查看堆的情况 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -heap 2815 2.dump 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:live,format=b,file=/tmp/heap2.bin 2815 或者 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -dump:format=b,file=/tmp/heap3.bin 2815 3.看看堆都被谁占了? 再配合zprofiler和btrace，排查问题简直是如虎添翼 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jmap -histo 2815 | head -10 jstatjstat参数众多，但是使用一个就够了 1sudo -u admin /opt/taobao/install/ajdk-8_1_1_fp1-b52/bin/jstat -gcutil 2815 1000 jdb时至今日，jdb也是经常使用的。jdb可以用来预发debug,假设你预发的java_home是/opt/taobao/java/，远程调试端口是8000.那么sudo -u admin /opt/taobao/java/bin/jdb -attach 8000. 出现以上代表jdb启动成功。后续可以进行设置断点进行调试。具体参数可见oracle官方说明http://docs.oracle.com/javase/7/docs/technotes/tools/windows/jdb.html CHLSDBCHLSDB感觉很多情况下可以看到更好玩的东西，不详细叙述了。 查询资料听说jstack和jmap等工具就是基于它的。 1sudo -u admin /opt/taobao/java/bin/java -classpath /opt/taobao/java/lib/sa-jdi.jar sun.jvm.hotspot.CLHSDB 更详细的可见R大此贴http://rednaxelafx.iteye.com/blog/1847971 plugin of intellij ideakey promoter快捷键一次你记不住，多来几次你总能记住了吧？ maven helper分析maven依赖的好帮手。 VM options 你的类到底是从哪个文件加载进来的？ 12-XX:+TraceClassLoading结果形如[Loaded java.lang.invoke.MethodHandleImpl$Lazy from D:\\programme\\jdk\\jdk8U74\\jre\\lib\\rt.jar] 应用挂了输出dump文件 12-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof集团的vm参数里边基本都有这个选项 jar包冲突把这个单独写个大标题不过分吧？每个人或多或少都处理过这种烦人的case。我特么下边这么多方案不信就搞不定你? mvn dependency:tree &gt; ~/dependency.txt打出所有依赖 mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId只打出指定groupId和artifactId的依赖关系 -XX:+TraceClassLoadingvm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 -verbosevm启动脚本加入。在tomcat启动脚本中可见加载类的详细信息 greys:scgreys的sc命令也能清晰的看到当前类是从哪里加载过来的 tomcat-classloader-locate通过以下url可以获知当前类是从哪里加载的curl http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject ALI-TOMCAT带给我们的惊喜(感谢@务观) 列出容器加载的jar列表 curl http://localhost:8006/classloader/jars 列出当前当当前类加载的实际jar包位置，解决类冲突时有用 curl http://localhost:8006/classloader/locate?class=org.apache.xerces.xs.XSObject 其他gprefhttp://www.atatech.org/articles/33317 dmesg如果发现自己的java进程悄无声息的消失了，几乎没有留下任何线索，那么dmesg一发，很有可能有你想要的。 1sudo dmesg|grep -i kill|less 去找关键字oom_killer。找到的结果类似如下: 12345[6710782.021013] java invoked oom-killer: gfp_mask=0xd0, order=0, oom_adj=0, oom_scoe_adj=0[6710782.070639] [&lt;ffffffff81118898&gt;] ? oom_kill_process+0x68/0x140 [6710782.257588] Task in /LXC011175068174 killed as a result of limit of /LXC011175068174 [6710784.698347] Memory cgroup out of memory: Kill process 215701 (java) score 854 or sacrifice child [6710784.707978] Killed process 215701, UID 679, (java) total-vm:11017300kB, anon-rss:7152432kB, file-rss:1232kB 以上表明，对应的java进程被系统的OOM Killer给干掉了，得分为854.解释一下OOM killer（Out-Of-Memory killer），该机制会监控机器的内存资源消耗。当机器内存耗尽前，该机制会扫描所有的进程（按照一定规则计算，内存占用，时间等），挑选出得分最高的进程，然后杀死，从而保护机器。 dmesg日志时间转换公式:log实际时间=格林威治1970-01-01+(当前时间秒数-系统启动至今的秒数+dmesg打印的log时间)秒数： 1date -d &quot;1970-01-01 UTC `echo &quot;$(date +%s)-$(cat /proc/uptime|cut -f 1 -d&apos; &apos;)+12288812.926194&quot;|bc ` seconds&quot; 剩下的，就是看看为什么内存这么大，触发了OOM-Killer了。 新技能getRateLimiter想要精细的控制QPS? 比如这样一个场景，你调用某个接口，对方明确需要你限制你的QPS在400之内你怎么控制？这个时候RateLimiter就有了用武之地。详情可移步http://ifeve.com/guava-ratelimite","categories":[],"tags":[]},{"title":"JumpGame","slug":"2019-03-13-JumpGame","date":"2019-03-13T01:52:33.000Z","updated":"2019-03-13T07:38:28.381Z","comments":true,"path":"2019/03/13/2019-03-13-JumpGame/","link":"","permalink":"http://zehai.info/2019/03/13/2019-03-13-JumpGame/","excerpt":"","text":"problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 1234&gt; Input: [2,3,1,1,4]&gt; Output: true&gt; Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.&gt; Example 2: 12345&gt; Input: [3,2,1,0,4]&gt; Output: false&gt; Explanation: You will always arrive at index 3 no matter what. Its maximum&gt; jump length is 0, which makes it impossible to reach the last index.&gt; key本题有两个易理解错的地方 达到最后一个index或者超过最后一个index是可以的 【2,5,0,0】第一个2可以跳两步，然后我们在5的基础上跳五步 本题采用贪心算法，算出局部最优解就可以了，当然也可以考虑dp，但本题没有这个必要 solution123456public boolean canJump(int[] nums) &#123; int reach = nums[0]; for(int i = 1; i &lt; nums.length &amp;&amp; reach &gt;= i; i++) if(i + nums[i] &gt; reach) reach = i + nums[i]; return reach &gt;= (nums.length-1) ? true : false; &#125; perfect1I&apos;m the perfect","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"SpiralMatrix","slug":"2019-03-12-SpiralMatrix","date":"2019-03-12T13:33:48.000Z","updated":"2019-03-12T14:53:42.503Z","comments":true,"path":"2019/03/12/2019-03-12-SpiralMatrix/","link":"","permalink":"http://zehai.info/2019/03/12/2019-03-12-SpiralMatrix/","excerpt":"","text":"54.problem Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: 12345678&gt; Input:&gt; [&gt; [ 1, 2, 3 ],&gt; [ 4, 5, 6 ],&gt; [ 7, 8, 9 ]&gt; ]&gt; Output: [1,2,3,6,9,8,7,4,5]&gt; Example 2: 12345678&gt; Input:&gt; [&gt; [1, 2, 3, 4],&gt; [5, 6, 7, 8],&gt; [9,10,11,12]&gt; ]&gt; Output: [1,2,3,4,8,12,11,10,9,5,6,7]&gt; key很简单的循环输出的例子，从【0,0】的位置顺时针扫一圈，然后缩小一圈，继续扫描，不过有一个细节就是第三次第四循环前，要判断一下,防止最后一层循环只有一行 solution123456789101112131415161718192021222324252627282930public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); if (matrix.length == 0) return ans; int rs = 0, re = matrix.length - 1;// rowStart rowEnd int cs = 0, ce = matrix[0].length - 1;// columnStart columnEnd while (rs &lt;= re &amp;&amp; cs &lt;= ce) &#123; for (int i = cs; i &lt;= ce; i++) &#123; ans.add(matrix[rs][i]); &#125; for(int j=rs+1;j&lt;=re;j++) &#123; ans.add(matrix[j][ce]); &#125; if(rs&lt;re&amp;&amp;cs&lt;ce) &#123; for(int k=ce-1;k&gt;cs;k--) &#123; ans.add(matrix[re][k]); &#125; for(int l=re;l&gt;rs;l--) &#123; ans.add(matrix[l][cs]); &#125; &#125; rs++; re--; cs++; ce--; &#125; return ans; &#125; perfect1yehh,I&apos;m the perfect","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[{"name":"Medium","slug":"Medium","permalink":"http://zehai.info/tags/Medium/"}]},{"title":"如何设置hexo的favico","slug":"2019-03-12-如何设置hexo的favico","date":"2019-03-12T10:35:17.000Z","updated":"2019-03-12T13:55:17.022Z","comments":true,"path":"2019/03/12/2019-03-12-如何设置hexo的favico/","link":"","permalink":"http://zehai.info/2019/03/12/2019-03-12-如何设置hexo的favico/","excerpt":"","text":"solutionsource 下放置32*32的favico.icon文件并在根目录的_config.yml中设置 favicon: /favicon.ico","categories":[{"name":"others","slug":"others","permalink":"http://zehai.info/categories/others/"}],"tags":[]},{"title":"如何将域名绑定到hexo","slug":"2019-03-12-如何将域名绑定到hexo","date":"2019-03-12T09:44:20.000Z","updated":"2019-03-12T13:55:17.022Z","comments":true,"path":"2019/03/12/2019-03-12-如何将域名绑定到hexo/","link":"","permalink":"http://zehai.info/2019/03/12/2019-03-12-如何将域名绑定到hexo/","excerpt":"","text":"problem很多人可能都有hexo博客，会有一个githubname.github.io的地址，然后自己可能想去买一个域名，方便记忆，但是解析后迟迟用不了，该文章就来详细描述一下步骤。 solution1.拥有一个githubname.github.io可以正常访问的域名，如我的GitHub博客：https://shawngoethe.github.io 2.购买域名，个人推荐阿里云，首年年费比较便宜，适合个人折腾，博客建议com,me,info,pro（专家）,mobi(kindle电子书的格式)，再不济可以选择tech，cc之类的，国外可以参考Linost之类的网页 3.购买域名进行实名认证，否则无法使用 4.进行解析：记录类型CNAME（进行转发），主机记录@（避免主机记录选择www，输入域名要多写www），记录值为shawngoethe.github.io,TTL选择10分钟就可以了 上述方法属于将我购买的zehai.info转发到了shawngoethe.github.io,还可以“记录类型”选择“A”来填写IPv4的地址，地址可以通过ping shawngoethe.github.io 来获得 5.修改代码：很多人忽视了要在源代码/hexoblog/source/目录下添加CNAME文件（注意没有尾缀），然后在该文件下填写zehai.info（可以兼容，www.zehai.info 和 zehai.info 两种访问方式，但如果填写 www.zehai.info 则只支持 www.zehai.info 一种访问方式） 6.等十分钟左右，让解析生效，好了，你可以访问我的hexo获取更多内容","categories":[{"name":"others","slug":"others","permalink":"http://zehai.info/categories/others/"}],"tags":[]},{"title":"MaximumSubarray","slug":"2019-03-10-MaximumSubarray","date":"2019-03-10T13:39:50.000Z","updated":"2019-03-12T13:55:17.020Z","comments":true,"path":"2019/03/10/2019-03-10-MaximumSubarray/","link":"","permalink":"http://zehai.info/2019/03/10/2019-03-10-MaximumSubarray/","excerpt":"","text":"problem Maximum Subarray Easy Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 1234&gt; Input: [-2,1,-3,4,-1,2,1,-5,4],&gt; Output: 6&gt; Explanation: [4,-1,2,1] has the largest sum = 6.&gt; Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. key我们定义一个和为第一位数，然后用curSum来保存递增量 ps ans–&gt;answer cur–&gt;cursor solution12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; int ans=nums[0], curSum=0; for (int i=0; i&lt;nums.length; i++) &#123; curSum = curSum + nums[i]; ans = Math.max(ans, curSum); curSum = Math.max(0, curSum); &#125; return ans; &#125;&#125; perfect12345678910class Solution &#123; public int maxSubArray(int[] nums) &#123; int dp = nums[0], maxSum=nums[0]; for (int i=1; i&lt;nums.length; i++) &#123; dp = dp&lt;0?nums[i]:nums[i]+dp; maxSum=Math.max(maxSum, dp); &#125; return maxSum; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"pow(x,n)","slug":"2019-03-10-pow-x-n","date":"2019-03-10T13:10:48.000Z","updated":"2019-03-12T15:31:45.190Z","comments":true,"path":"2019/03/10/2019-03-10-pow-x-n/","link":"","permalink":"http://zehai.info/2019/03/10/2019-03-10-pow-x-n/","excerpt":"","text":"problem \\50. Pow(x, n) Medium Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: 123&gt; Input: 2.00000, 10&gt; Output: 1024.00000&gt; Example 2: 123&gt; Input: 2.10000, 3&gt; Output: 9.26100&gt; Example 3: 1234&gt; Input: 2.00000, -2&gt; Output: 0.25000&gt; Explanation: 2-2 = 1/22 = 1/4 = 0.25&gt; Note: -100.0 &lt; x &lt; 100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] solution12345678910111213141516171819202122public double myPow(double x, int n) &#123; long N = n; if (N &lt; 0) &#123; x = 1 / x; N = -N; &#125; double ans = 1; double cur = x;//2 for (long i = N; i &gt; 0; i /= 2) &#123; if (i % 2 == 1) ans = ans * cur; cur = cur * cur; &#125; return ans; &#125;//偷懒方法public double myPow(double x, int n) &#123; return Math.pow(x, n); &#125; key其实先使用了偷懒的方法，调用Math库的pow方法，然后写过一版 123for(long i=N;i&gt;0;i--) &#123; ans=ans*cur;&#125; 这个会直接报超时的错误，因为的计算量会非常大，在计算（-1.00000，-2147483648）时候超时了，虽然我们可以通过判断x来避免这一个超时，但是我想到了，可以通过n/2来迅速减少相乘的次数。时间大概是8ms perfect12345678910111213141516171819202122232425262728class Solution &#123; public double findPower(double x,long n)&#123; if(n == Long.valueOf(1)) return x; if(n % 2 == 0)&#123; double half_pow = findPower(x,n/2); return half_pow * half_pow; &#125;else&#123; double half_pow = findPower(x,(n-1)/2); return half_pow * half_pow * x; &#125; &#125; public double myPow(double x, int n) &#123; if( n==0 ) return 1; long n_long = (long) n; if( n &gt; 0 ) return findPower(x,n); x = 1 / x; long n_long_abs = (long) Math.abs((long)n); if(n_long_abs == 1) return x; return findPower(x,n_long_abs); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"我在一个不属于我的地方游荡","slug":"2019-03-06-我在一个不属于我的地方游荡","date":"2019-03-06T08:39:50.000Z","updated":"2019-03-12T13:55:17.021Z","comments":true,"path":"2019/03/06/2019-03-06-我在一个不属于我的地方游荡/","link":"","permalink":"http://zehai.info/2019/03/06/2019-03-06-我在一个不属于我的地方游荡/","excerpt":"","text":"我在一个不属于我的地方游荡2019年的3月6日，距离我上一份工作离职，已经37天，日子过得虽然不好，但也不算差，好消息是阿len还陪着我，坏消息是一直过着异地恋的生活，不知道是为什么，是我进入了焦虑的状态，每天的日常就是投简历，思考人生，发呆，看up主秀恩爱 其实回顾前三次的找工作经历，哪次不是觉得自己快要变成咸鱼了，然后收到了一两个offer，不过今年的不同点就是，有三家，我已经过了用人单位的面试，却被卡在了人力资源部门的审核上，我时常恨自己的学历，却无法去原谅曾经高考的自己，写这篇文章的时候，我刚刚从清华的北门进入校园，下午两点半的宿舍区，没有一点噪音，天空的乌鸦鸣叫在空旷的校园回荡，仿佛，在感叹今日的好天气，阳光那么明亮，洒在光秃秃的树枝上。 17年考研复习期间埋下来的雷，最终还是爆炸了，18年，19年，20年，似乎时间过得很快，我丢失了那一次机会后，我似乎再也没有机会去投入身心去复习，每天的大脑里更多的是，好累啊，好烦啊，什么时候发工资啊。越生是怀念起无忧无虑的本科生活，天天不用担心我是谁，我在哪儿，学什么，可能唯一需要费点脑经的就是，中午吃啥 而现在，我走在一个不属于我的世界里，熟悉又陌生，我什么都不知道，因为我不知道我要干嘛，前方一个是找不到工作的工作方向，一个是会饿死的考研方向，世界很精彩，我却显得那么渺小，就深深想起来用人部门发信息和我说： 从技术层面上，我认为从工作年限上，你的水平是够的。对于候选人的学历背景上，央企有自身的痼疾，用人部门的话语权不一定大于人力部门，这个你也无须介怀。 工作的前三年对于一个工程师来说是至关重要的，如果喜欢这条路，就多花点时间，加油！江湖不大，有缘再见！ 不知道接下来应该做什么，或许这就是应试教育的悲哀，我也只能许愿，三月份能够拿到一个不错的offer，先活下来，我是子苏，一个快要得抑郁症的人。","categories":[{"name":"mood","slug":"mood","permalink":"http://zehai.info/categories/mood/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://zehai.info/tags/diary/"}]},{"title":"docker+springboot","slug":"2019-03-05-docker-springboot","date":"2019-03-05T13:26:10.000Z","updated":"2019-03-12T13:55:17.019Z","comments":true,"path":"2019/03/05/2019-03-05-docker-springboot/","link":"","permalink":"http://zehai.info/2019/03/05/2019-03-05-docker-springboot/","excerpt":"","text":"what在 pom.xml-properties中添加 Docker 镜像名称 123&lt;properties&gt; &lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;&lt;/properties&gt; plugins 中添加 Docker 构建插件： 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- Docker maven plugin --&gt; &lt;/plugins&gt;&lt;/build&gt; 在目录src/main/docker下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。 1234FROM openjdk:8-jdk-alpineVOLUME /tmpADD spring-boot-docker-1.0.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下: FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载 VOLUME ，VOLUME 指向了一个/tmp的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用/tmp作为工作目录。这个命令的效果是：在宿主机的/var/lib/docker目录下创建一个临时文件并把它链接到容器中的/tmp目录 ADD ，拷贝文件并且重命名 ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT 这样 Spring Boot 项目添加 Docker 依赖就完成了。","categories":[{"name":"docker","slug":"docker","permalink":"http://zehai.info/categories/docker/"}],"tags":[]},{"title":"dockerfile","slug":"2019-03-04-dockerfile","date":"2019-03-04T13:09:55.000Z","updated":"2019-03-12T13:55:17.016Z","comments":true,"path":"2019/03/04/2019-03-04-dockerfile/","link":"","permalink":"http://zehai.info/2019/03/04/2019-03-04-dockerfile/","excerpt":"","text":"what通过dockerfile写入程序、库、资源、配置参数等，来生成image文件，可以类比node的package.json或者nginx.conf的文件 format1234567891011121314151617181920## Dockerfile文件格式# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] .. # 1、第一行必须指定 基础镜像信息FROM ubuntu # 2、维护者信息MAINTAINER docker_user docker_user@email.com # 3、镜像操作指令RUN echo \"deb http://archive.ubuntu.com/ubuntu/ raring main universe\" &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo \"\\ndaemon off;\" &gt;&gt; /etc/nginx/nginx.conf # 4、容器启动执行指令CMD /usr/sbin/nginx build image1docker build 运行该命令时，根据dockerfile文件及上下文构建新的docker镜像，其中上下文是指dockerfile所在的本地路径或者网络路径url。 ps:dokcer build时候，会在后台守护进程daemon中进行，而不是cli（common line interface）中，构建前，构建进程将全部内容递归放到守护进程，将dockerfile文件放在（本就在空目录下构建）该目录下 还可以通过.dockerignore的文件来忽略上下文目录中的部分文件和目录，同.gitignore 通过-f命令指定文件位置，如： 1docker buid -f /path/to/dockerfile . image tag镜像标签docker build -t ngix/v3 cacheDocker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。 example12345678910111213141516171819mkdir mynginxcd mynginxvi Dockerfile//制作dokcerfileFROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html//save &amp;&amp; run this code in mynginxdocker build -t nginx:v1 .//v1 后面有一个空格和一个点//点代表当前目录//查看imagedokcer images//rundokcer run --name docker_nginx_v1 -d -p 80:80 nginx:v1//docker_nginx_v1为容器名//nginx:v1为image名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zehai.info/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://zehai.info/tags/docker/"}]},{"title":"NoSql-introduction","slug":"2019-03-04-NoSql-introduction","date":"2019-03-04T13:01:07.000Z","updated":"2019-03-12T13:55:17.017Z","comments":true,"path":"2019/03/04/2019-03-04-NoSql-introduction/","link":"","permalink":"http://zehai.info/2019/03/04/2019-03-04-NoSql-introduction/","excerpt":"","text":"why nosqlNoSql可以处理结构化，非结构化的数据，可以水平伸缩，在实时和批量数据分析中具有优势 difference","categories":[{"name":"database","slug":"database","permalink":"http://zehai.info/categories/database/"}],"tags":[]},{"title":"docker","slug":"2019-03-04-docker","date":"2019-03-04T03:07:16.000Z","updated":"2019-03-12T13:55:17.017Z","comments":true,"path":"2019/03/04/2019-03-04-docker/","link":"","permalink":"http://zehai.info/2019/03/04/2019-03-04-docker/","excerpt":"","text":"why docker 解决“在我的机子上可以正常工作”的问题 运维更好地管理服务 更好地迁移和拓展（任意平台运行） what is dockerdocker属于Linux容器的一种封装，和VM类似，但他不像VM一样虚拟在操作系统之上，而是和操作系统平级，程序运行在容器里，就和在真实的物理机上面运行一样 简单一点理解就是：程序运行在docker上和真机上几乎误差，将程序包装起来管理 名词解释 daemon：守护进程 Client：命令行 image：镜像，用来创建容器 container：运行组件，启动的image就是容器 registry：管理image的地方 install #ubuntu $ sudo apt-get install docker-ce docker-ce-cli containerd.io HelloWorld 1234&gt; sudo docker container run hello-world&gt; //他会先找本地，然后再去仓库下载&gt; //该过程将image变成容器，即image文件产生container文件&gt; 常用命令 docker pull image_name//拉取镜像 docker images//本地镜像 docker rmi xxx//remove image docker ps//view what docker is running docker ps -a //以下使用cn代替 container_name/container_id docker start|stop|restart cn docker attach cn//启动后进入容器 dokcer rm cn docker info docker search nginx","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zehai.info/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://zehai.info/tags/docker/"}]},{"title":"LineageOS16.0-RELEASE","slug":"2019-03-02-LineageOS16-0-RELEASE","date":"2019-03-02T12:12:52.000Z","updated":"2019-03-12T13:55:17.015Z","comments":true,"path":"2019/03/02/2019-03-02-LineageOS16-0-RELEASE/","link":"","permalink":"http://zehai.info/2019/03/02/2019-03-02-LineageOS16-0-RELEASE/","excerpt":"","text":"16.0正式发布我们从去年八月开始，努力将我们LineageOs的新特性移植到新版本的安卓上，非常感谢之前版本中的工作者们，我们才能够在这次的版本新特性中投入更多的精力，尤其是，隐私守护（Privacy Guard）和插件（su addon）上收到了了大量的提升建议。通过对Styles API的一些细微更改，他现在可以兼容安卓暗黑模式的默认实现，在未来，越来越多的三方应用将遵循系统风格，这意味着Styles API将允许在跨应用程序时获得更一致的体验。正如我们发布夏季第二次调研结果那样，我们将介绍Trust的新特性，首先是设备锁定时阻止新USB设备连接。请注意，由于基于底层，所以这个特性必须在每个设备底层中启用。Trebuchet现在还可以隐藏app以及在打开app前进行身份验证。该限制也仅在Trebuchet中，并非系统范围。我们认为16.0的分支已经达到了15.1版本的特性测试并做好了发布准备。随着16.0分支成为最新最活跃的分支，在2019.3.1，它将开始日更新构建，并且15.1将会移动到周更新。16.0版本将会从小部分机器开始运行，一些其他的机子如果准备好了，我们也会做一些小改动，开始构建，并通过改动构建脚本来更好地处理我们最新手机的，独特feature，以及由此产生的复杂问题 支持更新名单 Asus BQ Fairphone Google HTC Huawei LeEco Lenovo LG Moto Nextbit Nubia Nvdia OnePlus(my oneplus 5T receive 16.0) Oppo Samsung Sony Wileyfox Wingtech Xiaomi YU ZTE Zuk more 其他热门的ROM MoKee] crDroid MIUI Flyme PixelExperience 原文 Hello LineageOS 16.0We’ve been working hard since August to port our unique features to this new version of Android. Thanks to the major cleanup and refactoring done in the previous version, we were able to focus more on features and reliability this time; in particular, both Privacy Guard and the su addon received a sizeable amount of improvements. With some minor changes made to the Styles API, it is now compatible with what will eventually become the default implementation of dark mode in Android. In the future, more and more third party apps will follow the system style, meaning our Styles API will allow you to have a more coherent experience across apps. As we announced when the Summer Survey 2 results were posted, we will be introducing new features to Trust, beginning with the ability to block new USB device connections when device is locked. Please note that this feature has to be enabled on a per-device basis due to the layer at which this was implemented. Trebuchet is also now able to hide apps and require authentication before opening them. Please note that this restriction is limited to Trebuchet and is not system-wide. We feel that the 16.0 branch has reached feature parity with 15.1 and is ready for initial release. With 16.0 being the most recent and most actively-developed branch, on March 1st, 2019 it will begin receiving builds nightly and 15.1 will be moved to weekly builds. LineageOS 16.0 will be launching with a small selection of devices. Additional devices will begin receiving builds as they are ready and after we make minor change to our build scripts to better handle the unique features, and resulting complications, of the most modern devices. Upgrading to LineageOS 16.0 (Optional) Make a backup of your important data Download the build either from download portal or built in Updater app You can export the downloaded package from the Updater app to the sdcard by long-pressing it and then selecting “Export” in the popup menu Download proper addons packages (GApps, su…) for Android 9.0/Lineage OS 16.0 Make sure your recovery and firmware are up to date Format your system partition Follow the “Installing LineageOS from recovery” section on your device’s installation page Please note that if you’re currently on an official build, you DO NOT need to wipe your device. If you are installing from an unofficial build, you MUST wipe data from recovery before installing.","categories":[{"name":"phones","slug":"phones","permalink":"http://zehai.info/categories/phones/"}],"tags":[]},{"title":"java类的加载机制","slug":"2019-03-02-java类的加载机制","date":"2019-03-02T09:41:18.000Z","updated":"2019-03-12T13:55:17.012Z","comments":true,"path":"2019/03/02/2019-03-02-java类的加载机制/","link":"","permalink":"http://zehai.info/2019/03/02/2019-03-02-java类的加载机制/","excerpt":"","text":"写在最前面：该文章为笔记，来自纯洁的微笑 what is the loading of class类加载即： 将编译class文件中的二进制数据读到内存中方法区，然后在堆区通过java.lang.Class实例化对象，对方法区的数据进行操作 该加载过程包含首次使用加载，以及预加载 加载class文件的方式 本地 网络 zip，jar文件中 数据库 动态编译 类的生命周期","categories":[{"name":"Java","slug":"Java","permalink":"http://zehai.info/categories/Java/"}],"tags":[]},{"title":"ShoppingOffers","slug":"2019-03-02-ShoppingOffers","date":"2019-03-02T03:00:46.000Z","updated":"2019-03-12T13:55:17.019Z","comments":true,"path":"2019/03/02/2019-03-02-ShoppingOffers/","link":"","permalink":"http://zehai.info/2019/03/02/2019-03-02-ShoppingOffers/","excerpt":"","text":"problem In LeetCode Store, there are some kinds of items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price. You are given the each item’s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer. You could use any of special offers as many times as you want. examples Example 1: 12345678&gt; Input: [2,5], [[3,0,5],[1,2,10]], [3,2]&gt; Output: 14&gt; Explanation: &gt; There are two kinds of items, A and B. Their prices are $2 and $5 respectively. &gt; In special offer 1, you can pay $5 for 3A and 0B&gt; In special offer 2, you can pay $10 for 1A and 2B. &gt; You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.&gt; Example 2: 12345678&gt; Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]&gt; Output: 11&gt; Explanation: &gt; The price of A is $2, and $3 for B, $4 for C. &gt; You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. &gt; You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. &gt; You cannot add more items, though only $9 for 2A ,2B and 1C.&gt; solution123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class ShoppingOffers &#123; public static void main(String[] args) &#123; /*以下贴出测试方式，因为对ArrayList不熟悉，如有更好的方式，欢迎指出*/ List&lt;Integer&gt; price = new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; special = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; needs = new ArrayList&lt;Integer&gt;(); price.add(0, 2);price.add(1, 5); Integer[][] arr = new Integer[][] &#123;&#123;3,0,5&#125;,&#123;1,2,10&#125;&#125;; special.add((List&lt;Integer&gt;)Arrays.asList(arr[0])); special.add((List&lt;Integer&gt;)Arrays.asList(arr[1])); needs.add(0,3);needs.add(1,2); ShoppingOffers so = new ShoppingOffers(); int res = so.shoppingOffers(price, special, needs); System.out.println(res); &#125; public int shoppingOffers(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs) &#123; return shopping(price, special, needs); &#125; public int shopping(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs) &#123; int j = 0, res = dot(needs, price); for (List &lt; Integer &gt; s: special) &#123; ArrayList &lt; Integer &gt; clone = new ArrayList &lt; &gt; (needs); for (j = 0; j &lt; needs.size(); j++) &#123; int diff = clone.get(j) - s.get(j); if (diff &lt; 0) break; clone.set(j, diff); &#125; if (j == needs.size()) res = Math.min(res, s.get(j) + shopping(price, special, clone)); &#125; return res; &#125; public int dot(List &lt; Integer &gt; needs, List &lt; Integer &gt; price) &#123; int sum = 0; for (int i = 0; i &lt; needs.size(); i++) &#123; sum += needs.get(i) * price.get(i); &#125; return sum; &#125;&#125; key本题目采用动态规划的思路，我们带入测试样例1的 12345&gt;Input: [2,5], [[3,0,5],[1,2,10]], [3,2]&gt;即A=$2,B=$5&gt;3A=5$,1A+2B=10$&gt;需购买3A+2B&gt; 尝试 price 1:单买 16 2单买302套餐，还差2个B，则先算出2B的res为10，先试305套餐，A买超了，则退出305套餐，此时还有1210套餐，A买多了，退出套餐，两个套餐试完了，得到了单买两个B，$10的套餐，总价就为15元， 15（覆盖16） 3单买1210套餐，还差2A，0B，费用目前10元，先单买2A，费用4元，总价14元，然后先尝试305套餐，发现超，然后再试1210套餐，发现B超了，得到目前最低费用为14元 14（覆盖15） 问题的关键就在于clone的精髓之处，用来记录还需要多少零件的个数，使用递归，进行操作。如果不符合，（如买超了）直接break后，重新计算clone，直到special方法都试完了，然后才返回，如果一直都是break的状态则会返回单买的价格。 perfect123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; private Integer res; public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) &#123; res=Integer.MAX_VALUE; int[] parr=new int[price.size()]; int[] aarr=new int[needs.size()]; for(int i=0;i&lt;parr.length; i++)&#123; parr[i]=price.get(i); aarr[i]=needs.get(i); &#125; findMinimum(special, 0, aarr, parr, 0); return res; &#125; private void findMinimum(List&lt;List&lt;Integer&gt;&gt; special, int curOffer, int[] remain, int[] single, int total)&#123; if(total&gt;=res||curOffer==special.size()) return; int buyNow=buySingle(remain, single, total); if(buyNow&lt;res) res=buyNow; int[] newRemain=remainAfterUse(special.get(curOffer), remain); if(newRemain!=null) findMinimum(special, curOffer, newRemain, single, total+special.get(curOffer).get(remain.length)); findMinimum(special, curOffer+1, remain, single, total); &#125; private int[] remainAfterUse(List&lt;Integer&gt; special, int[] remain)&#123; int[] res=new int[remain.length]; for(int i=0;i&lt;remain.length;i++)&#123; res[i]=remain[i]-special.get(i); if(res[i]&lt;0) return null; &#125; return res; &#125; private int buySingle(int[] remain, int[] single, int total)&#123; for(int i=0; i&lt;remain.length; i++)&#123; total+=remain[i]*single[i]; &#125; return total; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"Node10值得关注的升级","slug":"2019-02-23-Node10值得关注的升级","date":"2019-02-23T07:12:13.000Z","updated":"2019-03-12T13:57:07.600Z","comments":true,"path":"2019/02/23/2019-02-23-Node10值得关注的升级/","link":"","permalink":"http://zehai.info/2019/02/23/2019-02-23-Node10值得关注的升级/","excerpt":"","text":"http2优势 更有效的网络利用率 引入 HTTP Header 压缩减小报文体积 在同一个连接中支持多路并发 支持 Server Push 多路复用（Multiplexing）由于HTTP连接，起初有要求限制同一域名下的请求有数量限制，超过则被阻塞，而HTTP2可以发起多重请求，如同时请求样式文件和脚本文件 二进制分帧 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 http2.0的格式定义更接近tcp层的方式，这张二机制的方式十分高效且精简。length定义了整个frame的开始到结束，type定义frame的类型（一共10种），flags用bit位定义一些重要的参数，stream id用作流控制，剩下的payload就是request的正文了。 server Pushhttp2.0能通过push的方式将客户端需要的内容预先推送过去 首部压缩（Header Compression) BigInt *fs.mkdir 和 fs.mkdirSync 支持递归参数 CLI Flag 自动补全 Windows 安装包优化","categories":[],"tags":[]},{"title":"Egg支持JS智能提醒","slug":"2019-02-23-Egg支持JSTS智能提醒","date":"2019-02-23T06:35:30.000Z","updated":"2019-03-12T13:55:17.016Z","comments":true,"path":"2019/02/23/2019-02-23-Egg支持JSTS智能提醒/","link":"","permalink":"http://zehai.info/2019/02/23/2019-02-23-Egg支持JSTS智能提醒/","excerpt":"","text":"本文章思路来自https://zhuanlan.zhihu.com/p/56780733 定位其实由于Egg本身的动态加载机制，所以JavaScript很难去做智能提醒（如变量定义检查），本次借鉴TS的动态生成d.ts，使用ts的Declaration Merging（声明合并）特性，读取JSDoc注释。 获取 更新egg-bin模块 package.json 添加 “egg”: { “declarations”: true } 实操，升级个人GitHub项目chum,执行 npm i egg-bin 将其从4.9.0–&gt;4.11.0并在package.json的尾部加上上述egg的kv，在根目录下生成tpyping文件夹，将app目录下的controller，model，以及根目录下的index，config目录都进行了ts文件生成 其实egg原生支持JavaScript，对于TS只是支持不推荐的态度，并没有使用TS去重构，本次智能提醒，应该是对JS一个劣势的补齐，解决方案也似乎借鉴了TS的方式，但又保留了人们书写JS的习惯","categories":[{"name":"framework","slug":"framework","permalink":"http://zehai.info/categories/framework/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://zehai.info/tags/egg/"}]},{"title":"ThreeSum","slug":"2019-02-19-15ThreeSum","date":"2019-02-19T14:34:18.000Z","updated":"2019-03-12T13:55:17.008Z","comments":true,"path":"2019/02/19/2019-02-19-15ThreeSum/","link":"","permalink":"http://zehai.info/2019/02/19/2019-02-19-15ThreeSum/","excerpt":"","text":"Problem123456789101112131415Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] Solution123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; nums.length - 2; i++)&#123; // 跳过重复元素 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 计算2Sum ArrayList&lt;List&lt;Integer&gt;&gt; curr = twoSum(nums, i, 0 - nums[i]); res.addAll(curr); &#125; return res; &#125; private ArrayList&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int i, int target)&#123; int left = i + 1, right = nums.length - 1; ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); while(left &lt; right)&#123; if(nums[left] + nums[right] == target)&#123; ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); curr.add(nums[i]); curr.add(nums[left]); curr.add(nums[right]); res.add(curr); do &#123; left++; &#125;while(left &lt; nums.length &amp;&amp; nums[left] == nums[left-1]); do &#123; right--; &#125; while(right &gt;= 0 &amp;&amp; nums[right] == nums[right+1]); &#125; else if (nums[left] + nums[right] &gt; target)&#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; Keytips：很久没有写Java了，花了点时间去整理了一些知识，所以上面的算法其实是ctrl+v的，现在整理一下list相关的知识： 1.List&lt;List&gt;为嵌套的list集合，声明方式 List&lt;List&gt; list = new Array() or List&lt;List&gt; list = new ArrayList&lt;&gt;();//recomend 2.List是一个接口，而ArrayList是List接口的一个实现类 List list = new List();//是错误的用法 List list = new ArrayList();//list会丢失ArrayList的trimToSize()方法 ArrayList list=newArrayList() 3.然后明天再回来重新写这道题","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"缓存","slug":"2019-02-19-缓存","date":"2019-02-19T12:12:14.000Z","updated":"2019-03-12T13:55:17.014Z","comments":true,"path":"2019/02/19/2019-02-19-缓存/","link":"","permalink":"http://zehai.info/2019/02/19/2019-02-19-缓存/","excerpt":"","text":"缓存why 高性能 例如：把查完的值缓存，下次直接访问 高并发 例如：把请求排队 difference（vs memcached) 特征 redis memchched 数据结构 更复杂的数据结构，更丰富的数据操作 集群 支持 不支持 性能 单核 多核 redis线程模型redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。 假设一个 Redis 服务器正在运作， 那么这个服务器的监听套接字的 AE_READABLE 事件应该正处于监听状态之下， 而该事件所对应的处理器为连接应答处理器。 如果这时有一个 Redis 客户端向服务器发起连接， 那么监听套接字将产生 AE_READABLE 事件， 触发连接应答处理器执行： 处理器会对客户端的连接请求进行应答， 然后创建客户端套接字， 以及客户端状态， 并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联， 使得客户端可以向主服务器发送命令请求。 之后， 假设客户端向主服务器发送一个命令请求， 那么客户端套接字将产生 AE_READABLE 事件， 引发命令请求处理器执行， 处理器读取客户端的命令内容， 然后传给相关程序去执行。 执行命令将产生相应的命令回复， 为了将这些命令回复传送回客户端， 服务器会将客户端套接字的 AE_WRITABLE 事件与命令回复处理器进行关联： 当客户端尝试读取命令回复的时候， 客户端套接字将产生 AE_WRITABLE 事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的 AE_WRITABLE 事件与命令回复处理器之间的关联。","categories":[{"name":"high_availability","slug":"high-availability","permalink":"http://zehai.info/categories/high-availability/"}],"tags":[]},{"title":"联合索引","slug":"2019-02-19-联合索引","date":"2019-02-19T08:27:23.000Z","updated":"2019-03-12T13:55:17.010Z","comments":true,"path":"2019/02/19/2019-02-19-联合索引/","link":"","permalink":"http://zehai.info/2019/02/19/2019-02-19-联合索引/","excerpt":"","text":"key当具备多个索引的时候，如：KEY 联合索引 (a,b,c)为索引，除(b,c)条件索引不会触发该索引表外，(a,b),(a,c),(a,b,c)均会触发上述联合索引，具体可参见explain的key类型，理论应该显示联立索引 如： EXPLAIN SELECT FROM TABLENAME WHERE a=’2222’ AND b=‘222’* 如果你设置多个单列索引，在explain下，key的值就为其单列的索引，如上述的a列","categories":[{"name":"database","slug":"database","permalink":"http://zehai.info/categories/database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://zehai.info/tags/sql/"}]},{"title":"树的后序遍历","slug":"2019-02-19-树的后序遍历","date":"2019-02-19T07:38:13.000Z","updated":"2019-03-12T13:55:17.013Z","comments":true,"path":"2019/02/19/2019-02-19-树的后序遍历/","link":"","permalink":"http://zehai.info/2019/02/19/2019-02-19-树的后序遍历/","excerpt":"","text":"definition1234567891011121314151617181920private static class BinaryNode&lt;AnyType&gt;&#123; BinaryNode(AnyType theElement) &#123; this(theElement, null, null); &#125; BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt, BinaryNode&lt;AnyType&gt; rt) &#123; element = theElement; left = lt; right = rt; &#125; AnyType element; BinaryNode&lt;AnyType&gt; left; BinaryNode&lt;AnyType&gt; right;&#125;private BinaryNode&lt;AnyType&gt; root; posOrder123456789public void posOrder(BinaryNode&lt;AnyType&gt; Node) &#123; if (Node != null) &#123; posOrder(Node.left); posOrder(Node.right); System.out.print(Node.element + \" \"); &#125; &#125; 1234567891011121314151617181920212223242526272829public void posOrder(BinaryNode&lt;AnyType&gt; Node)&#123; Stack&lt;BinaryNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); int i = 1; while(Node != null || !stack1.empty()) &#123; while (Node != null) &#123; stack1.push(Node); stack2.push(0); Node = Node.left; &#125; while(!stack1.empty() &amp;&amp; stack2.peek() == i) &#123; stack2.pop(); System.out.print(stack1.pop().element + &quot; &quot;); &#125; if(!stack1.empty()) &#123; stack2.pop(); stack2.push(1); Node = stack1.peek(); Node = Node.right; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zehai.info/categories/algorithm/"}],"tags":[]},{"title":"表内关联","slug":"2019-02-19-表内关联","date":"2019-02-19T07:37:35.000Z","updated":"2019-03-12T13:55:17.011Z","comments":true,"path":"2019/02/19/2019-02-19-表内关联/","link":"","permalink":"http://zehai.info/2019/02/19/2019-02-19-表内关联/","excerpt":"","text":"Inner Join SELECT column_listFROM t1INNER JOIN t2 ON join_condition1INNER JOIN t3 ON join_condition2…WHERE where_conditions; Example id name parentid 1 北京市 0 2 海淀区 1 3 北京xx大学 2 select a.name 市,b.name 区,c.name 名from address ajoin address b on b.parentid = a.idjoin address c on c.parentid = b.idjoin address d on d.parentid = c.id","categories":[{"name":"database","slug":"database","permalink":"http://zehai.info/categories/database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://zehai.info/tags/sql/"}]},{"title":"LongestCommonPrefix","slug":"2019-02-18-LongestCommonPrefix","date":"2019-02-18T14:47:36.000Z","updated":"2019-03-12T13:55:17.008Z","comments":true,"path":"2019/02/18/2019-02-18-LongestCommonPrefix/","link":"","permalink":"http://zehai.info/2019/02/18/2019-02-18-LongestCommonPrefix/","excerpt":"","text":"Problem Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 123&gt; Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]&gt; Output: &quot;fl&quot;&gt; Example 2: 1234&gt; Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]&gt; Output: &quot;&quot;&gt; Explanation: There is no common prefix among the input strings.&gt; Note: All given inputs are in lowercase letters a-z. solution12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; int minLength = minLength(strs); String same = \"\"; boolean isSame=false; outer:for(int i=0;i&lt;minLength;i++) &#123; char sameCharacter = strs[0].charAt(i); isSame = false; for(int j=0;j&lt;strs.length;j++) &#123; if(strs[j].charAt(i)==sameCharacter) &#123; isSame = true; &#125;else &#123; isSame = false; break outer; &#125; &#125; if(isSame=true)same+=sameCharacter; &#125; return same; &#125; private int minLength(String[] strs) &#123; // TODO Auto-generated method stub if(strs.length==0) &#123; return 0; &#125; int min = strs[0].length(); for(int i=1;i&lt;strs.length;i++) &#123; if(strs[i].length()&lt;min) &#123; min = strs[i].length(); &#125; &#125; return min; &#125;&#125; key数学题，没什么关键，但是这个解法，还是存在优化空间 Perfect123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) &#123; return \"\"; &#125; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; ++i) &#123; while (!strs[i].startsWith(prefix)) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) &#123; break; &#125; &#125; &#125; return prefix; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"ReverseInteger","slug":"2019-02-17-ReverseInteger","date":"2019-02-17T04:38:41.000Z","updated":"2019-03-12T13:55:17.008Z","comments":true,"path":"2019/02/17/2019-02-17-ReverseInteger/","link":"","permalink":"http://zehai.info/2019/02/17/2019-02-17-ReverseInteger/","excerpt":"","text":"ProblemGiven a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321Example 2: Input: -123Output: -321Example 3: Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Solution1234567891011121314151617181920class Solution &#123; public int reverse(int x) &#123; if (x == 0) &#123; return 0; &#125; int result =0; long result_l = 0; while (x != 0) &#123; result_l = result_l * 10 + x % 10; x = x / 10; &#125; if(result_l &gt;= Integer.MAX_VALUE||result_l &lt;= Integer.MIN_VALUE) &#123; return 0; &#125;else &#123; result = (int) result_l; &#125; return result; &#125;&#125; keys1.倒序很简单，取余赋给新数就可以了，不过注意JavaScript或者Python的int–&gt;float的情况 2.题目下面其实提示了int的范围，改题目1032个测试数据，有大概7个是超范围的验证数据，所以java中可以巧利用Integer.MAX来进行处理。 perfect12345678public int reverse(int x) &#123; long res = 0; while (x != 0) &#123; res = res * 10 + x % 10; x = x / 10; &#125; return (int)res == res ? (int)res : 0; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://zehai.info/categories/LeetCode/"}],"tags":[]},{"title":"如何生成tag和categories","slug":"2019-02-17-如何生成tag和categories","date":"2019-02-17T04:37:23.000Z","updated":"2019-03-12T13:55:17.009Z","comments":true,"path":"2019/02/17/2019-02-17-如何生成tag和categories/","link":"","permalink":"http://zehai.info/2019/02/17/2019-02-17-如何生成tag和categories/","excerpt":"","text":"12hexo new page tagshexo new page categories","categories":[{"name":"others","slug":"others","permalink":"http://zehai.info/categories/others/"}],"tags":[]},{"title":"为什么使用消息队列MQ","slug":"2019-01-24-为什么使用消息队列MQ","date":"2019-01-24T10:24:15.000Z","updated":"2019-03-12T13:55:17.008Z","comments":true,"path":"2019/01/24/2019-01-24-为什么使用消息队列MQ/","link":"","permalink":"http://zehai.info/2019/01/24/2019-01-24-为什么使用消息队列MQ/","excerpt":"","text":"从实习到后来的两份工作也写了不少的项目，在最近的一份工作用到了大量的消息队列（客服系统，会有大量的访客咨询消息），让我重新回顾了一下在大数据面前，为什么要用消息队列，怎么用好消息队列 理由 解耦 异步 削峰 解耦通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，不同微服务之间通信会更加解耦，A给BCDEF发送消息的时候，就不需要考虑他们是否宕机，如何重发等，只需要将信息发送到队列里，让他们自己去取就好了 异步假设用户请求需要写表，那么吧任务放进队列里，等待写入，前端可以先返回，可以减少用户的等待时间，或者采用多个机器同时写数据的不同部分，加快数据的处理 削峰就和平时用电一样，晚上电网的压力肯定会很大，如果直接把大量请求压到服务器，会直接宕机，但如果把请求排成队列，然后服务器从里面顺序取，虽然会增加延迟，但是不会宕机，满负荷运作而已 实际生产环境咨询系统大致分为：咨询核心，端模块，微信模块，分配模块等等，访客发送的咨询信息（web）可能先经过端模块，在咨询核心模块处理前进入队列，然后，分配模块根据用户的设置，如接入客服还是机器人，按什么权重进行分配，分配给哪一个业务组进行操作，来减轻咨询核心的压力 缺点1.系统可用性降低（MQ挂了咋整） 2.复杂度提升（消息没有重复消费，不会丢失） 3.一致性问题有待解决 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，比 RocketMQ、Kafka 低一个数量级 同 ActiveMQ 10 万级，支撑高吞吐 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic 数量对吞吐量的影响 topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 时效性 ms 级 微秒级，这是 RabbitMQ 的一大特点，延迟最低 ms 级 延迟在 ms 级以内 可用性 高，基于主从架构实现高可用 同 ActiveMQ 非常高，分布式架构 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可靠性 有较低的概率丢失数据 基本不丢 经过参数优化配置，可以做到 0 丢失 同 RocketMQ 功能支持 MQ 领域的功能极其完备 基于 erlang 开发，并发能力很强，性能极好，延时很低 MQ 功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 所以中小型公司，用 RabbitMQ 是不错的选择 大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。","categories":[{"name":"high_availability","slug":"high-availability","permalink":"http://zehai.info/categories/high-availability/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://zehai.info/tags/MQ/"}]},{"title":"递归优化","slug":"2019-01-23-递归优化","date":"2019-01-23T03:54:43.000Z","updated":"2019-03-12T13:53:24.934Z","comments":true,"path":"2019/01/23/2019-01-23-递归优化/","link":"","permalink":"http://zehai.info/2019/01/23/2019-01-23-递归优化/","excerpt":"","text":"递归优化原因：在 Java 中，每个线程都有独立的 Java 虚拟机栈。栈具有后入先出的特点，递归调用也是需要后调用的方法先返回，因此使用栈来存储递归调用的信息。这些信息存储在栈帧中，每个 Java 方法在执行时都会创建一个栈帧，用来存储局部变量表、操作数栈、常量池引用等信息。在调用方法时，对应着一个栈帧入栈，而方法返回时，对应着一个栈帧出栈。 随着栈帧frame的增多，将会导致Stack Overflow的报错，例如 1234567int f(int i)&#123; if(i == 1 || i == 2) return 1; else return (f(i - 1) + f(i - 2));&#125; 解决方法1：递归–&gt;非递归其实很简单，就是用一个临时变量，来保存中间的值，而不是压入堆栈中， 1234567891011//费波纳列数列，前两位是1，之后没位数是前两位数的和private static void fibonacci(int n) &#123; int temp1=1,temp2=1,temp; for (int i = 1; i &lt;=n ; i++) &#123; temp=temp1+temp2; temp1=temp2; temp2=temp; &#125; System.out.println();&#125;//粘贴于网上 解决办法2：递归–&gt;尾递归尾递归就是当函数在最后一步（尾部）调用自身，如： 123function f(x)&#123; return g(x);&#125; 以下算法来自阮一峰教程： 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 该算法并非是尾递归，因为其在返回值的时候进行了一个乘法操作，所以还是普通的递归，复杂度为O(n)，而如果改成尾递归，则： 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 该算法只需要计算 factorial(5,1) factorial(4,5) factorial(3,20) factorial(2,60) factorial(1,120) 在进入新的递归函数时，尾递归不再需要使用栈帧保存数据，允许抛弃旧的栈帧，那么只需要保存一个栈帧即可 参考资料： [阮一峰尾递归]（http://www.ruanyifeng.com/blog/2015/04/tail-call.html）","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://zehai.info/categories/algorithm/"}],"tags":[{"name":"regreesion","slug":"regreesion","permalink":"http://zehai.info/tags/regreesion/"}]}]}